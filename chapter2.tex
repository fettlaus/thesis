\chapter{Analyse eines Entwicklungssystems}\label{chap:analyse}
\minitoc
In diesem Kapitel soll aufgezeigt werden, woraus ein Entwicklungssystem
im Allgemeinen besteht und welche Anforderungen sich also für ein zu
entwerfendes \emph{Entwicklungssystem} ergeben.
\begin{definition}[Entwicklungssystem]
Zu einem \emph{Entwicklungssystem} gehören
alle Hard- und Softwareelemente, die nötig sind, um die Umsetzung eines
bestimmten Softwareprojektes zu erreichen. Die einzelnen Bestandteile eines
solchen \emph{Entwicklungssystems} sollen im Verlauf dieses Kapitels
identifiziert werden.
\end{definition}
\section{Grundlegende Konzeption}
\begin{figure}[H]
\centering
\def\svgwidth{\columnwidth}
\input{res/system.pdf_tex}
\caption{Das geplante Gesamtsystem}{Die "'Module"' werden über WLAN
vom Entwicklersystem gesteuert und übermitteln an dieses auch alle
Daten, die sie von ihrem jeweils angeschlossenen "`Ziel"' erhalten.}
\label{fig:sys}
\end{figure}
Der Grundgedanke hinter dem zu entwerfenden \emph{Entwicklungssystem} ist, dass
bereits bestehende Infrastruktur wie Ethernet oder WLAN für die \emph{"`Module"'}
genutzt wird, um die Steuerung der emph{"`Ziele"'} und die Erfassung der Daten auf
dem System des Entwicklers verfügbar zu machen und zusammenzufassen.

In \autoref{fig:sys} ist dargestellt, wie die eingezeichneten \emph{"`Module"'}
über WLAN in die bestehende Infrastruktur, symbolisiert durch einen
Access-Point, eingegliedert werden.
\begin{definition}[Zielsystem]
Das \emph{Zielsystem} ist das System, welches mit Hilfe des
\emph{Entwicklungssystems} relisiert werden soll.
\end{definition}
Die einzelnen \emph{"`Module"'} sind in der Lage, die Ein- und Ausgänge
der \emph{Zielsysteme ("`Ziele"')} direkt zu erfassen und zu manipulieren. Dies
ermöglicht es, Daten zu sammeln und weiterzuleiten, sowie auf die "`Ziele"'
zuzugreifen.

\section{Elemente eines Entwicklungssystems}
Die Elemente eines Entwicklungssystems lassen sich grob drei Kategorien
zuordnen. 

Zu bedenken ist, dass bei der Entwicklung von Soft- und Hardware viele der
einzelnen Elemente, auch kategorieübergreifend, miteinander interagieren. 
\subsection{Vorgehensmodell}
Zu jedem Entwicklungsprozesses gehört auch immer die Entscheidung über eine
Vorgehensweise. Viele Vorgehensweisen basieren dabei auf Vorgehensmodellen,
die in Industrie und Wirtschaft weit verbreitet sind. Als Beispiele lassen sich
hier das Wasserfallmodell, das V-Modell, Scrum oder auch Extreme Programming
nennen.

All diesen Modellen ist gemein, dass einige ihrer Schritte
unbedingt Unterstützung durch Soft- und Hardware bedürfen oder
diese die Entwicklung unter Umständen beschleunigen kann.

Da es eine klare Strukturierung zeigt, soll hier exemplarisch für alle
Vorgehensmodelle das \textbf{Wasserfallmodell} aufgeführt werden.

Andere Vorgehensmodelle strukturieren ihren Ablauf unterschiedlich, jedoch sind
diese Unterschiede für die Wahl der verwendeten Hard- und Software nur von
untergeordneter Relevanz, da die zentralen Entwicklungsschritte
identisch sind.

\subsubsection*{Wasserfallmodell}
Das Wasserfallmodell ist ein klassisches, nicht-iteratives Vorgehensmodell,
dessen Ablauf man sich anhand eines Wasserfalls gut visualisieren kann. 

\begin{figure}[!h]
\centering
\def\svgwidth{\columnwidth}
\input{res/wasserfallmodell.pdf_tex}
\caption{Ablauf eines Softwareprojektes nach dem Wasserfallmodell. Erstellt nach
\cite{WP01}}{Jedes Element in diesem Diagramm stellt einen der Schritte und
damit eine Phase des Waserfallmodells dar. Die Übergänge zwischen dein
einzelnen Phsen sind oft fest definiert.}
\label{fig:wasser}
\end{figure}

In \autoref{fig:wasser} ist der mögliche Ablauf eines Wasserfallsmodells
dargestellt.

In den \emph{Initialisierungs- und Analysephasen} wird oft der Kunde in die
Entwicklung eingebunden. Typischerweise werden hier deshalb keine oder nur
wenige spezialisierte Tools verwendet. Zu der verwendeten Software zählt hier
unter anderem \emph{Projektmanagementsoftware}.

Die \emph{Entwurfs- und Realisierungsphasen} jedoch benötigen oft eine hohe
Softwareunterstützung. Während in der Entwurfsphase meist Tools zur
Visualisierung und Strukturierung von Softwarearchitektur eingesetzt werden
\emph{(\gls{uml}, Struktogramme, etc.)}, werden in der Realisierungsphase
meist Werkzeuge eingesetzt, die von der konkreten Anforderung abhängen
\emph{(Compiler, \glspl{ide}, Debugger)}.

Um einen Übergang in die \emph{Einführungs- und Nutzungsphasen} zu ermöglichen,
muss die Software beziehungsweise das Gesamtsystem oft Tests durchlaufen, die das
System auf eine Erfüllung der Anforderungen überprüfen. Hierfür werden
häufig Testpraktiken benutzt, die auch soft- und hardwaregestützt
ablaufen. \emph{(\gls{jtag}, Unittests, In-circuit Tests)}

Um ein Ausliefern der Software zu ermöglichen, werden Werkzeuge zum Deployment
benötigt. Dies erfordert oft ein Zusammenspiel aus Hardware-
und Softwarekomponenten. \emph{(Installer, Softwarepakete, Flasher)}

Oft durchläuft ein System in seiner Nutzungsphase auch Wartungszyklen.
Diese Zyklen setzen eine möglichst einfache Wartbarkeit des Systems voraus.

\subsection{Software}\label{sub:software}
Software unterstützt Softwareprojekte in allen Phasen der Durchführung.

Obwohl viele dieser einzelnen Elemente auf Hardwareunterstützung angewiesen
sind, sollen in diesem Abschnitt nur die Softwarebestandteile beschrieben
werden. Soweit es nötig ist, werden die zugehörigen Gegenstücke in
\autoref{sub:hardware} beschrieben.
\begin{itemize}
  \item \subsubsection*{\glspl{ide}} \glspl{ide} sind zentrale
  Entwicklungsoberflächen der Softwareentwickler. In dieser Umgebung werden
  oftmals viele Tools zusammengefasst, die für den Entwicklungszyklus notwendig
  sind. Sie dienen dazu Quelltext zu verwalten und zu schreiben,
  Versionsverwaltung zu betreiben, Code zu kompilieren, die entwickelte Software
  zu testen, zu deployen und zu debuggen.
  
  Oft werden die in den folgenden Punkten aufgeführten Tools in eine IDE
  integriert, um Entwicklungsabläufe zu vereinfachen und zu beschleunigen.
  
  \emph{Beispiele:} Eclipse, NetBeans, CodeWarrior, Microsoft Visual Studio, Qt
  Creator
  \item \subsubsection*{Compiler} Compiler sind für viele Softwareprojekte von
  essentieller Bedeutung. Speziell im eingebetteten Bereich werden überwiegend
  kompilierte Programmiersprachen wie C oder C++ eingesetzt, da sie nach dem
  Kompiliervorgang in nativem Maschinencode vorliegen und so oft eine höhere
  Ausführungsgeschwindigkeit gewährleisten können. Außerdem können sie meist
  besser an das Zielsystem angepasst werden, da sie keiner weiteren Frameworks
  oder Interpreter mit "`überflüssigen"' Funktionen bedürfen.
  
  Soll eine kompilierte Software auf einem anderen als dem Entwicklungssystem
  eingesetzt werden, so wird ein sogenannter \textbf{Cross-Compiler} benötigt.
  Diese speziellen Compiler sind in der Lage, Software zu kompilieren, die
  später auf einer andere Rechnerarchitektur (z.B. ARM statt Intel) und/oder auf
  einem anderen Betriebssystem (z.B. Linux statt Windows) betrieben werden soll.
  
  \emph{Beispiele:} GCC, IAR C/C++ Compiler, ARM RVCT Compiler, Intel C++
  Compiler, CodeWarrior Compiler
  \item \subsubsection*{Debugger}\label{subs:swdebugger} Der Debugger ist ein
  Tool, mithilfe dessen ein Entwickler eine Software während ihrer Laufzeit
  untersuchen, steuern und, in einem gewissen Rahmen, modifizieren kann. Er
  dient dem Entwickler hauptsächlich zur Fehlersuche, da es mit seiner Hilfe
  sehr leicht ist, die Vorgänge in einer Software nachzuvollziehen.
  
  Der Entwickler ist durch das Setzen von Breakpoints\footnote{Willkürliche,
  vom Entwickler vor dem Start der Software zu setzende, "`Haltepunkte"' im
  Programmablauf.} mittels des Debuggers in der Lage, eine Software in einen
  definierten Zustand zu bringen. Anschließend kann er den weiteren
  Programmablauf schrittweise ausführen lassen (single-stepping) oder mitunter
  auch geringfügige Änderung am Speicher des Systems vornehmen.
  
  Debugger sind in integrierten Systemen oft auf eine hohe Hardwareunterstützung
  angewiesen. In \autoref{subs:hwdebugger} wird dies näher beschrieben.
  
   \emph{Beispiele:} GDB , IDB (Intel Debugger), Valgrind
  \item \subsubsection*{Testtools} In die Kategorie der Testtools fallen
  alle Elemente die benötigt werden, um die Funktionsfähigkeit eines Systems zu
  prüfen. Außerdem dienen diese auch oft dazu, ein Gesamtsystem sowie dessen
  Teilsysteme auf die Erfüllung der Anforderungen zu prüfen.
  
  Um die einzelnen Bestandteile eines Systems zu überprüfen, existieren viele
  verschiedene Ansätze. Meist werden Tests grob in \emph{Modultests},
  \emph{Integrationstests}, \emph{Systemtests} und \emph{Abnahmetests}
  unterteilt.
  
  Alle diese Testarten setzen jedoch eine grundlegende Testbarkeit des Systems
  voraus.
  
  \emph{Beispiele:} Unittests, \ldots  
  \item \subsubsection*{Deploymenttools}\label{subs:deployment} Um ein System
  ausliefern zu können, muss es für den Endanwender vorbereitet werden.
  
  Im Embeddedbereich erfolgt dies meist durch ein Übertragen der
  Firmware in den \gls{rom} des Zielsystems. Dieser Vorgang wird jedoch, zu
  Testzwecken, auch in der Entwicklungsphase eines Projektes oft durchgeführt
  und muss daher entsprechend einfach und möglichst unkompliziert sein.
  
  \emph{Beispiele:} Installer, Paketverwaltungssysteme, Skripte
\end{itemize}

\subsection{Hardware}\label{sub:hardware}
Welche Art von Unterstützung in welchem Umfang von Hardware geleistet werden
muss, ergibt sich oft aus den Projektvorgaben. Im Speziellen ist hierbei von
Bedeutung, welche Hardware als Zielsystem zum Einsatz kommt.
\begin{itemize}
  \item \subsubsection*{Testtools} Um Tests durchführen zu können, wird
  oft auch eine Unterstützung durch Hardware benötigt. 
  \begin{figure}[!h]
    \centering
    \def\svgwidth{\columnwidth}
    \input{res/boundaryscan.pdf_tex}
    \caption{Funktionsweise von \gls{jtag}. Erstellt nach \cite{ALT01}}
    \label{fig:ALT01}
  \end{figure}
  Der \gls{jtag}-Port ist ein System, welches ursprünglich für genau diese
  Zwecke konzipiert wurde. Er ermöglicht es, einen sogenannten boundary-scan
  durchzuführen. Jedes in \autoref{fig:ALT01} mit "`\gls{ic}"' markierte
  Bauteil muss dafür über einen, in der Abbildung nicht eingezeichneten, sogenannten \gls{tap} oder
  \gls{dap}\footnote{Wird von neueren ARM Kernen benutzt.
  Ermöglicht auch Tracing.} verfügen. Diese befinden sich \emph{nicht} in der
  Logik des Bauteils, sondern stellen eine separate Steuerschaltung dar.
  
  Die \glspl{tap}/\glspl{dap} werden verkettet und ermöglichen es, die Ein-
  und Ausgänge der einzelnen Bauteile mit Prüfdaten zu betreiben, Bauteile komplett
  zu überbrücken oder auch sie in ihrem Betrieb anzuhalten.
  Die in \autoref{fig:ALT01} als "`Zu testende Verbindung"' markierte Leitung
  kann so auf Unterbrechungen oder Überbrückungen geprüft werden.
  
  Einen darauf aufbauenden Funktionsumfang bietet das, vorwiegend in ARM
  Prozessoren zum Einsatz kommende, \gls{swd} an.
  
  Um (auch analoge) Bauteile und Platinen in größerem Umfang zu testen, dient
  der \emph{in-circuit Test}. Hierbei wird ein speziell angefertigtes
  "`Nagelbett"' auf eine Platine gesenkt. Dies erlaubt zusätzlich zum
  \emph{boundary-scan} das Testen von Widerständen, Kapazitäten und anderen
  elektrischen Kenngrößen.
   
  \emph{Beispiele:} \gls{jtag}-Debugger, \gls{swd}-Debugger, Spy-Bi-Wire,
  DebugWIRE, In-circuit Testanlagen
  \item \subsubsection*{Debugger}\label{subs:hwdebugger}  Um
  Softwaredebugging wie in \autoref{subs:swdebugger} beschrieben im Umfeld eines
  Mikroprozessors zu erleichtern beziehungsweise überhaupt zu ermöglichen,
  besitzen diese oft verschiedene Eigenschaften.
  Um eine Software Schritt-für-Schritt auszuführen, wird eine Unterstützung von
  der CPU vorausgesetzt. Prozessorkerne der ARM-Architektur lassen sich zum
  Beispiel mittels des \gls{dap}/\gls{tap} in einen Debug-Modus bringen.
  Dieser Debug-Modus ist Voraussetzung dafür, Single-Step-Debugging duchführen
  oder Breakpoints setzen zu können.
  
  Da ein \gls{jtag}-Port einen direkt Zugriff auf alle Eingänge eines
  Mikrocontrollers bietet und der \gls{dap}/\gls{tap} tief in die Hardware
  integriert ist, lassen sich über diese Verbindung oft auch Register,
  Speicherbereiche und andere Komponenten modifizieren. So kann ein
  \gls{jtag}-Debugger mitunter auch als \emph{Flasher} eingesetzt werden, wenn
  er in der Lage ist, den \gls{rom} zu beschreiben.
  
  \emph{Beispiele:} \gls{jtag}-Debugger, \gls{swd}-Debugger
  \item \subsubsection*{Flasher} Um, wie in \autoref{subs:deployment}
  beschrieben, ein Zielsystem mit einer Firmware beschreiben zu können, wird
  oft ein Hardwarebauteil benötigt.
  
  Abhängig vom verwendeten Zielsystem erfolgt ein "`Flashen"' dabei häufig über
  extra dafür bestimmte Hardware. Gängige Variante ist hierbei zum Beispiel die
  Verwendung eines \glspl{isp}. Ein \gls{isp} ist ein System, das speziell
  dafür ausgelegt ist, Firmware auf ein bereits eingebautes Bauteil zu übertragen.
  
  Auch bieten manche Zielsysteme eine Übertragung des Programmcodes über die
  \gls{jtag}-Schnittstelle an.
\end{itemize}
%%==================================================================
\section{Vorgaben des Zielsystems}
Die hier angeführten Punkte wurden als grundlegend für die Arbeit erachtet und
sind aus diesem Grund feste Vorgaben an das System und keine
Designentscheidungen. An dieser Stelle sollen lediglich die Gründe für
die Wahl dieser Vorgaben erläutert werden.

Das zu entwerfende Entwicklungssystem sollte ein möglichst
großes Spektrum potentieller Architekturen und Funksysteme abdecken können, so
dass es später einfach ist, das zu entwickelnde Zielsystem durch ein anderes zu
ersetzen.

Da Mikroprozessoren mit \textbf{ARM-Architektur} einen Anteil von rund
71\%\cite{IDC01} an allen verkauften \glspl{cpu} haben, sorgt dies allein für
eine hohe Austauschbarkeit. Dieser Umstand bedingt die Vorgabe, dass das
\emph{Entwicklungssystem} speziell auf die Entwicklung eines Zielsystems
mit ARM-Architektur ausgelegt sein soll. 

Es ist wünschenswert, die hohe Austauschbarkeit einzelner Bestandteile in
den weiteren Entscheidungen ebenso widerzuspiegeln.

<\ldots>

\section{Vorentscheidungen für das  Zielsystem} In diesem Abschnitt sollen die
Vorgaben für ein beispielhaftes Zielsystem erläutert und festgelegt werden. 
\subsection{Entwicklungssystem}
<Warum wir das Carambola wählten>
<Was das Carambola ist>
Das Carambola wird mit \textbf{OpenWRT}, einem linuxbasierten
Betriebssystem für eingebettete Geräte, betrieben. OpenWRT verfügt über eine große Anzahl
portierter Softwarepakete, unterstützt viele Architekturen (unter anderem ARM,
MIPS, PowerPC, x86) und gewährleistet durch simple Konfigurationsdateien einen
hohen Grad an Konfigurierbarkeit.
\subsection{Zielsystem}
Bedingt durch die hohe Verbreitung von ARM \glspl{cpu}
existiert eine große Anzahl an Entwicklungsboards, die in Frage kommen.

Es ist wichtig eine Entscheidung eher nach Kriterien der Energieeffizienz als
der Rechenleistung zu treffen, da das Zielsystem später stark integriert
arbeiten können soll.

Wählt man einen ARM-Kern nach der Energieeffizienz aus, fällt einem hierbei die
Reihe der Cortex-M Prozessoren auf. Sie liegen mit ihrem geringen Energiebedarf
in einem Bereich, der z.B. für Batteriebetrieb sehr gut geeignet ist. Aus diesem
Grund optimieren viele Chiphersteller, die Cortex-M Kerne verbauen, diese genau
dafür.

 <Warum der ARM von Olimex gut ist>

\subsection{Funkmodul} Die verfügbaren Funkmodule lassen sich grundsätzlich in
zwei Kategorien einteilen.

Jedes Funkmodul besteht mindestens aus einem \textbf{Transceiver}. Dieser
Transceiver umfasst zumindest die analogen Komponenten der physikalischen
Schicht wie Analog-Digital-Wandler, Digital-Analog-Wandler, Filter, Verstärker,
Frequenzerzeuger. Je nach Ausführung werden, ahängig davon ob der Transceiver
für ein spezifisches Protokoll eingesetzt werden soll, auch die Bauteile des
Medium-Access-Layers (Checksummenprüfung, Buffer, Kollisionsvermeidung) in
einen Transceiver integriert.

Für viele Funkprotokolle stehen jedoch auch \textbf{Single-Chip Solutions}
zur Verfügung. Diese Bauteile bestehen sowohl aus einem Transceiver als auch,
neben anderen Bauteilen, aus einem eigenen Mikrocontroller. Dieser übernimmt die
Aufgaben höherer Schichten und wird dafür oft über einfache Protokolle wie UART
oder SPI angesprochen.

Dies bedeutet jedoch gleichzeitig mehr Hardware, da ein integrierter
Mikroprozessor betrieben werden muss und somit Strom benötigt.
Außerdem verhindert die hohe Abstraktion der Kommunikation genauere Einblicke in
deren Abläufe. Da das Ziel dieser Arbeit jedoch auch sein soll die
Visualisierung von Kommunikationsabläufen zu ermöglichen, kann eine zu starke
Abstraktion hinderlich sein.


 <Warum genau dieses Modul die einfachste Wahl ist>
%%======================================================================
\section{Anforderungen an ein konkretes System (Lastenheft)}
Nachdem nun klar ist, aus welchen Bestandteilen ein Entwicklungssytem besteht
und welches Zielsystem eingesetzt werden soll, müssen nun die
konkreten Anforderungen gestellt werden.

Diese Anforderungen sollen als Ziel dieser Arbeit erfüllt werden und eine
Entwicklung des Zielsystems ermöglichen.

All diesen Anforderungen ist gemein, dass sie "`ferngesteuert"' funktionieren
müssen. Hierfür können bereits existierende Infrastrukturen (WLAN,
Ethernet) genutzen werden.

\subsection{Debugging} Die Entwicklung einer Software und die Suche nach Fehlern
in dieser wird durch den Einsatz eines Debuggers enorm erleichtert. 

\begin{minipage}[c]{\textwidth}
Gefordert wird:
\begin{itemize}
  \item Die Möglichkeit, das Zielsystem schrittweise zu Debuggen
  \item Eine Integration in eine Entwicklungsoberfläche(\gls{ide})
\end{itemize}
\end{minipage}

\subsection{Deployment} Für das Deployment, sowohl testweise und zu
Debuggingzwecken während der Entwicklung als auch für die endgültige
Fertigstellung, ist es erforderlich, die einzelnen Knoten des Zielsystems mit
einer neuen Firmware beschreiben zu können.

Da es sich bei dem Zielsystem in seiner Gesamtheit um eine Vielzahl identischer
Komponenten handelt, sollte sich dieser Prozess im Idealfall auf
eine beliebige Anzahl an Zielsystemen ausweiten lassen. Es wäre wünschenswert,
eine Anzahl von Komponenten in einem einzigen Schritt mit einer Firmware
beschreiben zu können.

\subsection{Datenanalyse} Die Möglichkeit ein Entwicklungssystem beliebige
Daten als "`Debuginformationen"' ausgeben zu lassen erlaubt es, eine
Übersicht über die zeitlichen Abläufe zu erstellen. Gerade für die
Zusammenarbeit miteinander interagierender Module ist es also wichtig, diese
Informationen zentral zu sammeln und sortieren, um sie später zur
Fehlersuche heranziehen zu können.

Zur Umsetzung dieses Systems müssen also zwei Komponenten erstellt werden:
\begin{enumerate}
  \item Eine zentrale Verwaltungseinheit, die Daten aggregieren und verwalten
  kann
  \item Ein Gegenstück, das die Daten eines einzelnen Moduls sammelt und an die
  Verwaltungseinheit weiterleitet
\end{enumerate}


\iffalse

%%=============================================================================
\section{Softwareunterstützung}
Für eine neue Entwicklungsplattform ist es wünschenswert, sich nicht von einem
speziellen Vorgehensmodell abhängig zu machen. Es sollte also eine Schnittmenge
gefunden werden, um die Minimalanforderungen möglichst vieler Modelle abdecken
zu können.

Als Schnittmenge kristallisieren sich dabei folgende Aspekte heraus:
\begin{itemize}
  \item \subsection*{Programmieren} Eine Softwareunterstützung erfolgt in diesem
  Schritt meist durch eine IDE und/oder einen Compiler.
  \item \subsection*{Testen} Je nach Art der Tests wird auch in diesem Schritt
  Softwareunterstützung benötigt. 
  \item \subsection*{Verteilen} Soll eine Software auf mehrere
  Systeme verteilt werden, passiert dies fast immer softwaregestützt.
  \item \subsection*{Warten} Die Wartung einer Software ist ein weiterer
  wichtiger Bestandteil des Softwarelebenszyklus'.
\end{itemize}
\section{Vorbedingungen durch das zu entwickelnde System}\label{sec:vorb}
Entwicklung von Software für funkende Mikrocontroller. Dies Mikrocontroller sind
teilweise hochgradig in ihre Umgebung integriert. So können diese z.B.
nicht für die Entwicklung kurzfristig ausgebaut werden. Aufgrund ihrer extrem
hohen Verbreitung\footnote{Referenz} bezieht sich diese Arbeit ausschließlich
auf Systeme mit ARM-Architektur.
\section{Weitere Gegebenheiten}\label{sec:gegeb}
Es existiert Infrastruktur, die man sich für die Entwicklung zu Nutze machen
kann. Hierzu zählen zum Beispiel WLAN, Stromversorgung, Ethernet.

\section{Randbedingungen des Entwicklungsprozesses}
Die gegebenen Umständen aus \autoref{sec:gegeb} und \autoref{sec:vorb} ergeben
folgende Randbedingungen:
\begin{itemize}
  \item Das Zielsystem ist nie auch gleichzeitig das Entwicklungssystem.
  Zusätzlich zu der Tatsache, dass die Zielsysteme eine andere
  \item Das Zielsystem interagiert mit Umgebung. Deshalb sind zum Beispiel
  Funkstörungen o.Ä. zu beachten
  \item Der Zielsystemort ist selten auch der Entwicklungsort
  \item Es existieren viele Zielsysteme mit gleicher oder ähnlicher
  Konfiguration
\end{itemize}

\section{Anforderungen an das Entwicklungssystem}
Aus den Randbedingungen ergeben sich harte und weiche Anforderungen an ein
potentielles Entwicklungssystem. Die harten Anforderungen müssen von einem
Entwicklungssytem zwangsweise erfüllt werden um als geeignetes System dienen zu
können. Die Erfüllung weicher Anforderungen kann den den
Entwicklungsprozess vereinfachen und dem Entwickler die Arbeit erleichtern.
\subsection{Harte Anforderungen}
\begin{itemize}
  \item Schon während der Entwicklung muss ein Zugriff auf das Zielsystem zum
  Debuggen möglich sein
  \item Software muss "`remote"' deployt werden können
  \item Tests sollten aus Simulationsgründen vor Ort erfolgen
  \item Wartungszyklen und Wartungsupdates müssen meist für viele Systeme
  parallel duchgeführt werden
\end{itemize}
\subsection{Weiche Anforderungen}
\begin{itemize}
  \item 
\end{itemize}


\section{Entwicklungsmodelle}
Unterschiedliche Anforderungen je nach Entwicklungsziel
Manche stimmen jedoch überein, so z.B.
  



Abhängig von den Vorgaben und den eingesetzten Entwicklungsmodellen werden
für jedes Softwareprojekt unterschiedliche Anforderungen an die verwendete Hard-
und Software gestellt.

Diese Anforderungen 

 Je nach Art der Software, Anforderungen und

Unabhängig von der Wahl des Entwicklungsmodells können und
müssen viele dieser Schritte teilweise auch softwaregestützt ablaufen. Es ist
daher für ein Entwicklungssystem zwingend notwendig, diese Schritte zu
unterstützten.

Zu den softwaregestützten Schritten zählen hierbei:
\begin{itemize}
  \item \subsection*{Modultest} Modultest
  \item \subsection*{Integrationstest} Integrationstest eingebetteter Systeme
  erfolgen meist mit Hilfe standardisierter Verfahren. Diese verfahren lassen
  sich oft auch zum Beispiel in die Endkontrolle von herstellungsprozessen
  integrieren. So sind in der Industrie verfahren wie \gls{jtag} oder
  Pintests weit verbreitet.
  \item \subsection*{Deployment} Im Bereich der 
  \item \subsection*{Wartung}
\end{itemize}

\ldots
\section{JTAG}
JTAG statt SWD
\begin{itemize}
  \item Wird von viele Prozessoren unterstützt.
  \item Ermöglicht ein umfangreiches Debuggen des Prozessors bis auf
		Registerebene.
  \item OpenOCD hat bereits viele Funktionen.
\end{itemize}
\section{Netzwerkprotokoll}
\subsection{Zeitsynchronisation}
\section{Serversoftware}

\section{Clientsoftware}
\fi