\chapter{Realisierung}
\minitoc
In diesem Kapitel wird die Realisierung des Entwicklungssystems
beschrieben. <\ldots>
\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{aufbau.png}
\caption{Aufbau des Entwicklungssystems}{Diese Fotografie zeigt einen
Teil des aufgebauten Entwicklungssystems. Erkennen lassen sich im
Vordergrund die "`Carambolas"', die über zwei Leitungen mit dem \gls{uart} des
roten "`Zielsystems"' verbunden sind. Über USB sind an die "`Carambolas"' die
grauen \gls{jtag}-Adapter angeschlossen, die ihrerseits ebenso mit den
"`Zielsystemen"' verbunden sind.}
\label{fig:aufbau}
\end{figure}
\section{Konfiguration des Carambola}\label{sec:conf}
OpenWRT bietet mit dem Programm \gls{uci} eine Anwendung, Einstellungen
zentralisiert zu verwalten. Über das \gls{uci}-System lassen sich unter anderem
Ethernet, WLAN, DHCP und SSH-Server konfigurieren. Die einzelnen
Einstellungsdateien liegen alle im Verzeichnis \listinlsh{/etc/config/} und
können mittels des Tools modifiziert werden.

Nach Systemstart werden außerdem alle Dateien im Ordner
\listinlsh{/etc/uci-defaults/} eingelesen, ausgeführt und anschließend gelöscht.
Dies erlaubt es Softwarepaketen, Einstellungen am System vorzunehmen. Werden
diese Softwarepakete bereits in die Firmware integriert, entspricht dies einer
Art \textbf{Vorkonfiguration} des gesamten Systems.

Da alle diese Einstellungen für das zu entwerfende Entwicklungssystem spezifisch
sind, wird diese Datei zusammen mit der kompilierten Serveranwendung installiert
und nach einem Neustart beziehungsweise einem ersten Systemstart ausgeführt.
\subsection{WLAN und Netzwerkkonfiguration}
Da die Netzwerkkonfiguration von OpenWRT vollständig durch die
\gls{uci}-Konfigurationsdateien abgewickelt wird, muss auch \gls{uci} genutzt
werden, wenn das Netzwerk vorkonfiguriert werden soll.

\gls{uci} bietet mit \listinlsh{uci batch} explizit einen Befehl an, um
umfangreiche Einstellungsändeurngen vorzunehmen. Hierfür werden die einzelnen
Befehle mittels \emph{Here document} übergeben.

\begin{definition}[Here document]
Ein \emph{Here document} ermöglicht es, einem einzelnen Unix-Befehl mehrere,
durch Zeilenumbrüche getrennte, Befehle zu übergeben.
\end{definition}
Die Verwendung des \emph{Here documents} ist dabei wie folgt. Die zu tätigenden
Einstellungen befinden sich dabei an der Stelle des mit
\listinlsh{<Einstellungen>} bezeichneten Bereichs. Ein abschließendes
\listinlsh{commit network} weist das \gls{uci} an, die Einstellungen zu
speichern.
 \begin{lstlisting}[language=sh]
uci batch <<-EOF_network
	<Einstellungen>
	commit network
	EOF_network
\end{lstlisting}
Da diese Einstellungen nur einmalig getätigt werden müssen, wird dafür die in
\autoref{sec:conf} erwähnte Datei in \listinlsh{/etc/uci-defaults/} verwendet.

\subsection{Aktivierung des UART}\label{subs:aktuart}
Der Mikrochip\cite{RA01} des Carambolas besitzt zwei \glspl{uart}. Einer dieser
\glspl{uart} wird für die Serielle Konsole über den RS232-Anschluss des
Carambolas verwendet. Somit kann der zweite Anschluss für die
Datenschnittstelle des Entwicklungssystems verwendet werden.
Da die Pins des Carambolas für den zweiten \gls{uart} standardmäßig auf
\gls{gpio}-Betrieb eingestellt sind, müssen diese erst umgestellt werden.

Hierzu muss das Tool \texttt{io} installiert und mittels 
\listinlsh{io 0x10000060 0x01} ausgeführt werden. Dies weist den
Mikrocontroller an, den \gls{uart} zu aktivieren. Dieser Vorgang muss nach jedem
Systemstart erfolgen und kann durch die, bei jedem Systemstart aufgerufene,
Datei \listinlsh{/etc/rc.local} erfolgen.

Zusätzlich muss verhindert werden, dass auf diesem \gls{uart} eine Linuxterminal
betrieben wird. Hierzu muss die Datei \listinlsh{/etc/inittab} modifiziert
werden.

Diese beiden Änderungen werden wie folgt ebenso mittels des Skripts in
\listinlsh{/etc/uci-defaults/} nach \autoref{sec:conf} durchgeführt.
\begin{lstlisting}[language=sh]
sed -i '/exit 0/ i\io 0x10000060 0x01' /etc/rc.local
sed -i '/ttyS0/ s/^/# /' /etc/inittab
\end{lstlisting}

\section{OpenOCD}
Für OpenOCD existiert keine Portierung in die Paketverwaltung von OpenWRT. Es
muss also ein Makefile erstellt werden, das die Einbindung ermöglicht. Der
grundlegende Aufbau solcher Makefiles ist im Wiki von OpenWRT
festgelegt\cite{OWRT}.
\subsection{Portierung auf OpenWRT}
Um OpenOCD kompilieren zu können, müssen zuerst die Voraussetzungen festgestellt
werden. Da ein auf dem FT2232-Chip basierender \gls{jtag}-Adapter mit
USB-Anschluss eingesetzt werden soll, müssen laut \texttt{README} von OpenOCD
sowohl libftdi als auch libusb installiert sein. Diese Pakete stehen für OpenWRT
bereits zur Verfügung und müssen im Makefile als Abhängigkeiten definiert
werden. Dies geschieht mit dem Befehl \listinlsh{DEPENDS:=+libftdi +libusb}.

Der Quellcode von OpenOCD in der Version 0.6.1 wird durch das Makefile von
Sourceforge selbstständig heruntergeladen, über MD5 verifiziert und entpackt.

Um eine hohe Kompatibilität gegenüber allen möglichen Zielsystemen zu
gewährleisten, musste das \texttt{Makefile} der \texttt{libftdi} angepasst werden, da die in den
Repositories vorhandene Version 0.19  keine Kommunikation mit Adaptern
gewährleistet, die einen FT232H-Chip besitzen. Diese Funktion gewährleistet erst
Version 0.20.

Vor dem Kompilierungsvorgang müssen noch die an \listinlsh{./configure}
zu übergebenden Argumente festgelegt werden. Der verwendete Adapter
verwendet einen FT2232H-Chip und erfordert daher die Option
\listinlsh{--enable-ft2232_libftdi}.
Die Option \listinlsh{--enable-parport} wird in der \texttt{README} von OpenOCD als
empfohlen angegeben und aktiviert die Unterstützung für \gls{jtag}-Adapter, die
den Parallelport verwenden.

\begin{lstlisting}[language=make]
CONFIGURE_ARGS+= \
	--prefix=$(STAGING_DIR)/usr \
	--enable-dummy \
	--enable-parport \
	--enable-ft2232_libftdi
\end{lstlisting}

Zu den Kompilerargumenten muss die Option
\listinlsh{-Wno-error=maybe-uninitialized} hinzugefügt werden, da anderenfalls
eine den Kompiliervorgang abbrechende Warnung beim Kompilieren der Datei
\listinlsh{src/target/dsp5680xx.c} auftritt.
\subsection{Integration in Eclipse}
Da OpenOCD neben einer Telnet-Konsole auch die Möglichkeit bietet, über einen
\gls{gdb}-Client darauf zuzugreifen, ist die Einbindung in verschiedenste
Entwicklungsumgebungen oft denkbar einfach.

So bieten zum Beispiel "`Qt Creator"', "`Netbeans"' oder auch "`Eclipse"' eine
Unterstützung für gdb. <cite>

Für diese Arbeit soll exemplarisch eine Verbindung zum Entwicklungssystem
mittels Eclipse hergestellt werden.

Hierfür

<\ldots>
\section{Server - FreeJTAG}
Der "`FreeJTAG"' genannte Server des Entwicklungssystems wird auf dem Carambola
installiert, als Serveranwendung bei jedem Systemstart gestartet und leitet die
gesammelten Daten an jeden verbundenen Client weiter.


\subsection{Bibliotheken und Abhängigkeiten}
Als Bibliotheken kommen bei FreeJTAG vor allem Teile der \emph{Boost Bibliothek}
zum Einsatz. Diese dienen der asynchronen Netzwerkkommunikation (\emph{Boost
ASIO}), dem hierfür nötigen Einsatz von Threads (\emph{Boost Thread}), der
Verwaltung der Zeitstempel (\emph{Boost Chrono}) und dem Speichern und
Einlesen von Programmeinstellungen (\emph{Boost Program\_Options}).

Außerdem hängt FreeJTAG von dem Paket "`io"' ab, da dieses für die Aktivierung
des \gls{uart}, wie in \autoref{subs:aktuart} beschrieben, zuständig ist und
installiert werden muss. Die in \autoref{sec:conf} beschriebene Skriptdatei,
die mittels \listinlsh{/etc/uci-defaults/} eine Vorkonfiguration durchführt, ist
ebenso in diesem Paket enthalten.

Durch die Installation dieser Anwendung wird das Carambola also komplett für den
Einsatz als Entwicklungssystem konfiguriert.

\subsection{Strukturierung der Serversoftware}
\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{server.eps}
\caption{Grober Aufbau der Serveranwendung}{Diese Abbildung verdeutlicht den
Aufbau der Serveranwendung (FreeJTAG). Hierbei wurden Details zu Gunsten der
Übersichtlichkeit ausgelassen.}
\label{fig:server}
\end{figure}
\autoref{fig:server} stellt eine grobe Übersicht über den Aufbau der
Serveranwendung dar. Hierbei wurden Details wie weitere Klassen und
zusätzliche Aggregationen zwischen den einzelnen Elementen zugunsten einer
besseren Übersicht ausgelassen.

Die Hauptanwendung \texttt{Freejtag} dient als "`Bindeglied"' zwischen den
einzelnen Bestandteilen der Software. Die genaueren Abläufe hierzu sollen in
\autoref{subs:abl} erläutert werden.

Weiterhin besteht die Serversoftware aus einer Klasse
\texttt{NetworkService} zur Übertragung der Nutzdaten, \texttt{DatagramService}
um die Zeitsynchronisation über UDP zu managen und \texttt{UARTService} für den
Empfang der Daten vom Zielsystem.

Die Klasse \texttt{Message} dient zum Parsen der Netzwerkdaten und wird somit
sowohl vom TCP- als auch vom UDP-Dienst verwendet.

Da die Zeitstempel synchronisiert werden sollen, wurde die Klasse
\texttt{TimeKeeper} erstellt. Sie dient dem Setzen der Zeitdifferenz und der
Abfrage des aktuellen Zeitstempels unter Berücksichtigung der gespeicherten
Differenz.

Die Hilfsklasse \texttt{BlockingQueue} wird als Schnittstelle zwischen dem
Hauptprogramm und dem \texttt{UARTService} sowie zwischen dem Hauptprogramm
und dem \texttt{NetworkService} eingesetzt. Sie ist nötig, da jeder dieser
Dienste in einem anderen Thread läuft und der Datenaustausch aus diesem Grund
synchronisiert werden muss.

\subsection{Funktionsweise der Serversoftware}
In diesem Abschnitt sollen die wichtigsten Abläufe in der Serveranwendung
erläutert werden. Der Schwerpunkt liegt hierbei hauptsächlich auf der
Synchronisierung der Zeit und dem Weiterleiten der gesammelten Daten.
\subsubsection*{Programmstart}\label{subs:start}
Die Anwendung wird zuerst initialisiert und anschließend ausgeführt. Dies
erfolgt durch folgenden Ablauf.
\begin{lstlisting}[language=C++]
int main(int argc, char* argv[]) {
    freejtag::Freejtag *prog;
    prog = new freejtag::Freejtag(argc, argv);
    int res = prog->run();
    delete prog;
    return res;
}
\end{lstlisting}

Für die Funktion dieser Software müssen zu Beginn einige Einstellungen
festgelegt werden. Hierzu zählen die Parameter der \gls{uart}-Verbindung
(Baudrate, Parität, Stopp-Bit) und der Netzwerkport.

Bei Erstellung des \texttt{Freejtag}-Objektes werden zuerst die Werte aus
\listinlsh{/etc/freejtag.cfg} und die per Parameter (und in diesem Fall
Kommandozeile) übergebenen Argumente als Einstellungen eingelesen.
Das Einlesen dieser Werte erfolgt unter Nutzung der
\emph{Boost.Program\_options}-Bibliothek. Tritt hierbei ein Fehler auf, wird das
Programm mit einer Fehlermeldung beendet.

Intern werden die über das Netzwerk zu versendenden und empfangenen Nachrichten
mittels \listinlcpp{boost::shared\_ptr}(Smart Pointer) von
\texttt{Message}-Objekten verwendet. Es muss nun eine \\\texttt{BlockingQueue}
initialisiert werden, die die über den TCP-Port empfangenen Nachrichten
verwaltet. Da asynchrone TCP-Sendevorgängen mittels der
\listinlcpp{boost::asio}-Bibliothek erfolgen, ist eine weitere
\texttt{BlockingQueue} zur Synchronisierung hierfür nicht notwendig.

Da es möglich sein soll mehrere Verbindungen (Siehe auch \autoref{subs:best}) zu
verwalten, muss in der \texttt{BlockingQueue} zusammen mit der \texttt{Message}
auch immer die Verbindung von der sie erhalten wurde gespeichert werden.

Eine zweite \texttt{BlockingQueue} dient zur Erfassung der über UART gesammelten
Daten mit zugehörigen Zeitstempeln. 

Nun werden sowohl \texttt{NetworkService} als auch \texttt{DatagramService}
initialisiert.

Der \texttt{NetworkService} erhält hierfür die vorher erstellte
\texttt{BlockingQueue}(den Buffer), legt das Protokoll auf TCP fest und
öffnet den in den Einstellungen spezifizierten Port. Der Ablauf des
\texttt{DatagramService} verläuft analog mit dem Unterschied, dass für die über
diesen Dienst erfolgende Zeitsynchronisation kein Zugriff auf den
Nachrichten-Buffer nötig ist.

Anschließend werden zwei Threads gestartet, die für die Abwicklung der, durch
den Empfang von UART- oder Netzwerkdaten angestoßenen, Vorgänge zuständig
ist. Hierfür warten die Threads mittels \listinlcpp{UARTMessage msg =
input_uart_.pop();} beziehungsweise \newline\listinlcpp{MessageDatagram msgd =
input_network_.pop();} auf die Ankunft neuer Daten in ihrere zugehörigen
\texttt{BlockingQueue}. Dies schließt die Initialisierung ab.

Nun muss nun \listinlcpp{Freejtag::run();} aufgerufen werden, um den Start der
Anwendung zu vollziehen. Dies startet ein asynchrones Accept auf dem Socket des
Netzwerkmoduls, so dass es nun möglich ist, eine Verbindung zum Server
herzustellen. Der \gls{uart}-Anschluss wird auf dem angegebenen Gerät geöffnet
und mit den eingestellten Parametern konfiguriert.

Schließlich ruft der startende Thread die blockierende Methode
\listinlcpp{io_service_.run();} auf und dient nun zur Abarbeitung der
asynchronen Netzwerkvorgänge.
\subsubsection*{Zeitsynchronisation}
Der Ablauf erfolgt wie in \autoref{subs:time} beschrieben.

<näher erläutern>

Da nun die Abweichung zur Clientsoftware ermittelt wurde, kann die Funktion
\newline\listinlcpp{TimeKeeper::set(microseconds difference)} verwendet werden,
um diesen Wert zu speichern. Durch diese Justierung wird der \texttt{TimeKeeper}
in diesem Augenblick effektiv auf \SI{0}{\micro\second} gesetzt.

Der aktuelle Zeitstempel wird bei Abfrage durch eine simple Subtraktion
errechnet.
\begin{lstlisting}[language=C++]
static high_resolution_clock::time_point epoch;
microseconds TimeKeeper::time(){
    high_resolution_clock::duration now = 
    			high_resolution_clock::now() - epoch;
    return duration_cast<microseconds>(now);
}
\end{lstlisting}

\subsubsection*{Empfang und Weiterleitung von UART-Daten}
Die Hauptfunktion des Servers liegt im Weiterleiten von über den
\gls{uart}-Anschluss erhaltenen Daten.

Ein beispielhafter Ablauf ist in \autoref{fig:serveruart} abgebildet.

Sobald die asynchrone Empfangsroutine des \texttt{UARTService} aufgerufen wird,
fragt diese den aktuellen Zeitstempel über den \texttt{TimeKeeper} ab. Zu
diesem Zweck besitzt dieser die statische Funktion \listinlcpp{time()}, die den
aktuellen Zeitpunkt in Mikrosekunden wie in \autoref{subs:servertime}
erläutert zurückgibt.

Anschließend wird der Zeitstempel zusammen mit der erhaltenen Textzeile in die
Buffer-Queue gegeben. Aus dieser Queue wird dieses Zeitstempel-Nachrichten-Paar
abgeholt und mittels \listinlcpp{NetworkService::sendBroadcast(Message::pointer
msg)} asynchron an alle verbundenen Clients gesendet.

Die Entkoppelung zwischen \texttt{UARTService} und \texttt{uart\_handle()}
mittels Buffer wird nötig, um das System möglichst modular zu halten. So wäre es
zum Beispiel eine Erweiterung um SPI-Funktionalität denkbar. Hierfür müsste
lediglich der gleiche Buffer an einen zu erstellenden \texttt{SPIService}
übergeben werden.

\begin{figure}
\centering
\begin{sequencediagram}
\newthread[0]{uart}{:UARTService}
\newinst[9pt]{time}{:TimeKeeper}
\newinst[9pt]{queueuart}{:BlockingQueue}
\newthread[9pt]{uartdisp}{uart\_handle()}
\newinst[9pt]{net}{:NetworkService}
\begin{call}{uart}{time()}{time}{timestamp}
\end{call}
\setthreadbias{west}
\begin{call}{uart}{push()}{queueuart}{}
\end{call}
\setthreadbias{center}
\prelevel{4}
\begin{call}{uartdisp}{pop()}{queueuart}{Data}
\postlevel{4}
\end{call}
\begin{call}{uartdisp}{sendBroadcast()}{net}{}
\end{call}
\end{sequencediagram}
\caption{Ablauf bei Empfang einer Zeile von \gls{uart}}{In diesem Ablauf
werden die Vorgänge nach Empfang einer Zeile des \gls{uart} dargstellt. Hierbei
ist zu beachten, dass der \texttt{UARTService}, anders als hier eingezeichnet,
keinen eigenen Thread besitzt. Stattdessen wird ein asynchrones
Ereignis ausgelöst.}
\label{fig:serveruart}
\end{figure}
\subsubsection*{Beenden des Servers}
Zum Beenden der Serveranwendung wird eine \texttt{EXIT}-Nachricht an den Server
geschickt.
\begin{minipage}[c]{\textwidth}
Dieser führt anschließend folgende Schritte aus:
\begin{itemize}
  \item Ausgeführt duch Thread \texttt{network\_dispatcher\_}
  \begin{itemize}
  \item Variable \texttt{\_running} auf \listinlcpp{false} setzen
  \item Acceptor für neu ankommende Verbindungen schließen
  \item Auf dem Socket der TCP-Verbindung ein \listinlcpp{socket\_.shutdown()}
  und \listinlcpp{socket\_.close()} ausführen, um die Verbindungen zu schließen
  \item Den Seriellen Port des \texttt{UARTService} mittels
  \listinlcpp{port\_.close()} schließen
  \item Den Socket des UDP-Servers mittels \listinlcpp{socket\_.close()}
  schließen
  \item Da keine Netzwerkoperationen anstehen, ist der Hauptthread nun nicht
  mehr auf  \listinlcpp{io\_service\_.run()} blockiert
  \end{itemize}
  \item Ausgeführt durch Hauptthread
  \begin{itemize}
    \item Den auf \listinlcpp{input\_network\_.pop();} blockierenden
    \texttt{network\_dispatcher\_} unterbrechen
    \item Den auf \listinlcpp{input\_uart\_.pop();} blockierenden
    \texttt{uart\_dispatcher\_} unterbrechen
  \end{itemize}
\end{itemize}
\end{minipage}
\section{Client - The Kraken}
\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{client.png}
\caption{Die Clientanwendung}{Diese Abbildung zeigt die Clientanwendung
"`The Kraken"' beim Erfassen der gesammelten Daten. Ein bei den
Zielsystemen gleichzeitig ausgelöster Interrupt ist erkennbar.}
\label{fig:client}
\end{figure}
\subsection{Funktionalität}
Die Clientsoftware dient dem Erfassen und Anzeigen der von der Serversoftware
gesammelten Daten. \autoref{fig:client} stellt die Oberfläche der Software dar.

\begin{minipage}[l]{\textwidth}
Die Software erfüllt folgende Funktionen:
\begin{itemize}
  \item Verbindungsaufbau zu einer beliebigen Anzahl Server
  \item Sortierung der Daten. (Siehe \autoref{subs:sort})
  \item Beenden einer Serveranwendung
  \item Senden von \texttt{MESS}-Nachrichten an einen Server (Broadcast)
  \item Unterbrechen der Datenaufnahme
  \item Synchronisieren der Zeiten aller Serveranwendungen mit dem Client
  \item <weitere Funktionen> 
\end{itemize}
\end{minipage}
\subsection{Aufbau der Anwendung}
Die Strukturierung der Clientanwendung folgt lose dem \gls{mvp}-Modell nach
Martin Fowler<cite!>.

<ausführlicher>

Der EventBus der \emph{Google Guava}-Bibliothek wird verwendet, um die
Ereignisse der Softwareelemente miteinander zu verknüpfen.

Die Anwendung wurde mithilfe des Build-Management-Tools "`Maven"'
entwickelt.
\subsection{Sortierung der Daten}\label{subs:sort}
Da die Daten im Betrieb fortlaufend eintreffen, wird eine entsprechende Methode
benötigt, die Daten zu sortieren.

Ein Sortieralgorithmus wie zum Beispiel "`Quicksort"' funktioniert nur so lange,
wie die Daten konsistent bleiben. Da sie das in diesem Fall jedoch nicht sind,
ist nach einer alternativen Lösung zu suchen.

Ein \textbf{TreeSet} sorgt dafür, dass die Daten direkt beim Eintreffen nach
ihren Zeitstempeln in den Baum einsortiert werden. Dies erlaubt es relativ
einfach, das jeweils kleinste Element (das Element mit dem niedrigsten
Zeitstempel) auszugeben. 

Hierbei muss jedoch sichergestellt werden, dass immer eine Anzahl an Nachrichten
in diesem Buffer verbleibt. Die Größe des Buffers beträgt aus diesem Grund
$\mathit{AnzahlVerbindungen}*3$.

\section{Deployment}
\begin{itemize}
  \item Scripting von OpenOCD
  \item Einbindung in Eclipse
\end{itemize}
<\ldots>
\section{Aufgetretene Probleme}
Während der Inbetriebnahme von OpenOCD traten häufig Probleme mit der
Verbindung zum \gls{jtag}-Adapter auf. Dies äußerte sich darin, dass das
Linux-System regelmäßig die Verbindung zu dem Adapter verlor. Dies
erschwerte den Betrieb von OpenOCD erheblich.

Jedoch ist dies offensichtlich ein bekanntes Konstruktionsproblem der
"`Carambolas"' hervorgerufen durch eine unzulängliche Schirmung des
USB-Anschlusses gegenüber Elektromagnetischen Wellen.\cite{CARAM2} Dies bewirkt,
dass die integrierte WLAN-Antenne den Betrieb von USB-Geräten unter Umständen
stark beeinflusst.

Um dieses Problem zu beheben wurde ein \SI{32}{\mm} langer Draht an die Masse
der WLAN-Antenne gelötet. Anschließend lies sich der \gls{jtag}-Adapter
problemlos betreiben. Alternativ hätte auch die Möglichkeit bestanden, die
Sendeleistung des WLAN-Moduls über die Einstellung \listinlsh{option txpower 10}
in der Datei \listinlsh{/etc/config/wireless} zu reduzieren.
\section{Analyse des Systems}
Da die Präzision der Zeitstempel von zentraler Bedeutung für die
Aussagekraft der gesammelten Daten ist, muss festgestellt werden, wie exakt zum Beispiel die
Zeitsynchronisation funktioniert.

Um die Genauigkeit messen zu können, müssen alle Zielsysteme möglichst
zeitgleich ein Signal erhalten, um dann unverzüglich über \gls{uart} eine
Nachricht an die angeschlossenen "`Carambolas"' zu übermitteln.

Hierfür wurde exemplarisch das \gls{rtos} ChibiOS/RT\cite{CHIB} auf den
Zielsystemen installiert. Es wurde so konfiguriert, dass ein Interrupt ausgelöst
wird, sobald ein bestimmter Pin als "`Auslöser"' auf Masse gezogen wird.

Da die "`Carambolas"' alle verschiedene Massepotentiale haben, müssen diese
zuerst miteinander verbunden werden. Anschließend kann man alle
"`Auslöser"'-Pins miteinander verbinden. Dies erlaubt es einem, mittels eines
Knopfes oder eines Überbrückungskabels, die so verbundenen Pins zeitgleich
auszulösen.

Hat man vorher einen Synchronisierungsvorgang durch den Client durchgeführt,
lässt sich durch die Differenz der Zeitstempel nun die tatsächliche Abweichung
voneinander messen. Im Idealfall ist die Differenz hierbei möglichst gering
(Nach \autoref{subs:time} weniger als \SI{1}{\milli\second}). Das Eintreffen
dieser erwähnten Interrupts ist auch auf \autoref{fig:client} zu erkennen.

Allerdings kann dies natürlich nur die Differenzen der Zielysteme untereinander
aufzeigen. Die Abweichung gegenüber dem Entwicklerrechner ist für eine Analyse
der Netzwerkabläufe jedoch auch von untergeordneter Relevanz, da dieser in den
Abläufen keine Rolle spielt.

\begin{figure}
\centering
\begin{tabu}{r|r r|r r | r}
& \multicolumn{2}{c|}{\textbf{Knoten 0}} & \multicolumn{2}{c|}{\textbf{Knoten
1}} & \textbf{Knoten 2}\\ \cline{2-6}
Minute & Zeitstempel & Diff zu Knoten 1& Zeitstempel &
Diff zu Knoten 2& Zeitstempel \\ \hline
0  & 10613705   & -21\us   & 10613684   & 175\us   & 10613859   \\
15 & 950992475  & 6423\us  & 950998898  & 12465\us & 951011363  \\
30 & 1854818581 & 12581\us & 1854831162 & 24298\us & 1854855460 \\
45 & 2754582459 & 18743\us & 2754601202 & 36158\us & 2754637360 \\
60 & 3655782708 & 24897\us & 3655807605 & 47868\us & 3655855473 \\
75 & 4554104959 & 30989\us & 4554135948 & 59647\us & 4554195595 \\
90 & 5453785960 & 37080\us & 5453823040 & 71543\us & 5453894583 \\ \hline
& \multicolumn{2}{p{4,7cm}}{\textbf{Drift pro \SI{15}{\minute}
gegenüber Knoten 1}} & \multicolumn{2}{|p{4,7cm}|}{\textbf{Drift pro \SI{15}{\minute}
gegenüber Knoten 2}} &
\\
& \multicolumn{2}{c}{\textbf{\SI{6,180}{\ms}}} &
\multicolumn{2}{|c|}{\textbf{\SI{11,924}{\ms}}}&
\\
\end{tabu}\\
\caption{Testdaten einer Testreihe zur Prüfung der Genauigkeit der
"`Carambolas"'}{Die Zeitstempel sind die von der Clientsoftware
ausgegebenen Werte. Der durchschnittliche Drift über \SI{15}{\minute} errechnet
sich über die Differenz zwischen den einzelnen Knoten nach einer Testzeit von
\SI{90}{\minute}.}
\label{fig:testtab}
\end{figure}

Es wurde ein Testtlauf über \SI{90}{\minute} durchgeführt. Direkt vor dessen
Durchführung wurde eine Zeitsynchronisation des gesamten
Entwicklungssystems und damit aller "`Carambolas"' durchgeführt.

Im Versuchsablauf wurde, wie weiter oben erläutert, ungefähr alle
\SI{15}{\minute} ein Interrupt bei allen Zielsystemen gleichzeitig ausgelöst.
Bei diese Testreihe war nicht entscheidend, den Interrupt exakt alle
\SI{15}{\minute} auszulösen, da hauptsächlich die sich verändernden Differenzen
gezeigt werden sollten.

Wie aus \autoref{fig:testtab} ersichtlich, ist direkt nach der Synchronisation
die absolute Differenz zwischen "`Knoten 0"' und "`Knoten 1"' bei nur
\SI{21}{\us} und zwischen "`Knoten 1"' und "`Knoten 2"' bei \SI{175}{\us}. Dies
zeigt, dass die Zeitsynchronisation eine ziemlich hohe Genauigkeit erreicht.

Aus dem Verlauf der Testreihe ist jedoch auch ersichtlich, dass die Differenz
zwischen den Systemen nicht gleichbleibend ist. So steigt über einen Zeitraum
von \SI{15}{\minute} die Differenz zwischen "`Knoten 0"' und "`Knoten 1"' um
ungefähr \SI{6,180}{\ms} und zwischen "`Knoten 1"' und "`Knoten 2"' um
\SI{11,924}{\ms}.

Dies erklärt sich aus den Fertigungstoleranzen der Schwingquarze. Die Abweichung
zwischen "`Knoten 0"' und "`Knoten"' vergrößert sich alle \SI{15}{\minute} um
ungefähr \SI{18}{\us} was einer Abweichung von 20 ppm entspricht
($\frac{\SI{18}{\us}}{\SI{15}{\minute}}*1000000=20\mathit{ppm}$).
Diese Abweichung ist für einen Schwingquarz noch innerhalb der üblichen
Frequenztoleranz.

Die Genauigkeit der Zeitsynchronisation selbst jedoch liegt in der in
\autoref{subs:time} geforderten Genauigkeit von ungefähr \SI{1}{\ms}.
