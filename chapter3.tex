\chapter{Konzeption}
\minitoc
In diesem Kapitel soll das Entwicklungssystem konzipiert werden.
Dazu muss jedes Element auf seine zu erfüllende Funktion untersucht werden.

Hieraus ergibt sich im Anschluss der anzufordernde Funktionsumfang, den der
jeweilige Bestandteil zu erfüllen hat.

Nach einer Analyse bereits existierender Systeme folgt schließlich die
Festlegung auf ein Entwicklungsziel.

Letztendlich muss sichergestellt werden, dass alle einzelnen Komponenten in dem
zu planenden System miteinander interagieren. Es müssen
Schnittstellenspezifikationen festgelegt werden.
\section{Debugging}
\subsection{Definition}
Das Debugging eines eingebetteten Systems erfordert meist eine kombinierte Hard-
und Softwarelösung.

Der Softwareteil ist oft in die \gls{ide} des Entwicklers eingebunden oder lässt
sich zumindest vom Arbeitsplatz des Entwicklers aus steuern. Die Befehle des
Entwicklers (Setzen eines Breakpoints, Abfrage von Registerwerten, etc.) werden
vom Softwaretreiber anschließend in Steuerbefehle des Hardwarebauteils
umgesetzt. Das Hardwaremodul übernimmt hierauf, unter Nutzung eine
standardisierten Schnittstelle, die Kommunikation mit dem Zielsystem.

Als Schnittstellen sind für diese Zwecke vor allem \gls{jtag} und \gls{swd}
verbreitet. Während \gls{jtag} ursprünglich primär zum Testen von Bauteilen
konzipiert wurde, erweitert \gls{swd} dieses Konzept um speziell für das
Debuggen nützliche Funktionen (Tracing, Paritätschecks) und reduziert die Anzahl
zwingend notwendiger Pins von 4 auf 2. Da \gls{swd} aber von
ARM speziell für Prozessoren mit eingebautem CoreSight-Modul entwickelt wurde,
ist Unterstützung hierfür nicht auf allen ARM-Controllern anzutreffen. \gls{jtag}
hat hier eine wesentlich größere Verbreitung und wird auch
architekturübergreifend genutzt. Die Wahl von \gls{jtag} würde eine spätere
Erweiterung auf andere Architekturen somit erleichtern.
\subsection{Marktübersicht}
Die Auswahl bereits existierender Netzwerk-Debugging-Lösungen ist geradezu
minimal.
Als eigenständige Lösung findet sich hier zum Beispiel \emph{ZY1000 (Ultimate
Solutions Inc.)}\cite{ULT} oder \emph{WiFiDemon (Macraigor Systems)}\cite{MAC}.
Beide Systeme stellen eine Schnittstelle zwischen Ethernet oder WLAN dar und sind somit
bereits existierende Umsetzungen des geplanten \emph{Entwicklungssystems}, wenn
man es auf den Aspekt des Debugging reduzieren würde.

Beide Lösungen sind jedoch geschlossene Systeme. Wollte man also, wie
vorgesehen, zusätzliche Daten sammeln, müsste man ein weiteres Gerät (mit
eigenem Anschluss an das Netzwerk) verwenden.

Betrachtet man die Softwareseite des Debuggings, landet man beinahe
zwangsläufig beim Open Source Projekt \textbf{OpenOCD}. Dieses Projekt ist im
Rahmen einer Diplomarbeit\cite{OOCD2} an der FH Augsburg entstanden und hatte
die Entwicklung einer quelloffenen Software zum Debuggen von
ARM-Mikrocontrollern zum Ziel. OpenOCD fungiert dabei als Schnittstelle zwischen
einem \gls{jtag}-Debugger und einer Benutzeroberfläche.

OpenOCD lässt sich dabei entweder über eine eigene Benutzeroberfläche via
Telnet-Protokoll oder mittels eines \gls{gdb}-Clients bedienen.
\begin{definition}[GDB]
Der \gls{gdb} ist der Standard-Debugger unter
Unix-Betriebssystemen. Er bietet unter Anderem die Möglichkeit, ein Programm im
laufenden Betrieb anzuhalten, Breakpoints zu setzen oder Single-Stepping
durchzuführen. Der GDB besitzt keine grafische Oberfläche, sondern
lässt sich über eine Kommandozeile bedienen. Er bietet die Möglichkeit, von
einem Client über TCP/IP ferngesteuert zu werden. 
\end{definition}
\subsection{Cross-Compilierung}
In einigen Fällen ist es nicht praktikabel oder schlicht unmöglich, dass eine
Anwendung auf der CPU-Architektur kompiliert wird, die auch später die
ausführende Architektur ist. Dies kann zum Beispiel dann der Fall sein, wenn ein
engebettetes System über nicht ausreichend Ressourcen (Speicherplatz) verfügt,
um den Kompilationsvorgang durchzuführen.

In diesen Fällen kommt ein sogenannter \emph{Cross-Compiler} zum Einsatz.
\subsection{OpenWRT - Paketverwaltung und Kompiliervorgang}
OpenWRT besitzt mit \textbf{opkg} ein Tool zur Paketverwaltung von Anwendungen.
Hierbei kann die Software in Form von *.ipk-Files aus "`Repositories"'
installiert werden. Durch dieses Tool wird es möglich, das eingebettete System
für die eigenen Bedürfnisse anzupassen.
\begin{definition}[Repository]
Ein \emph{Repository} enthält kompilierte Anwendungen für ein bestimmtes
Betriebssystem und eine spezifische Architektur. Über eine
Paketverwaltungssoftware kann auf das Repository zugegriffen, Software
heruntergeladen und installiert werden. Abhängigkeiten gegenüber anderen
Softwarepaketen werden meist selbstständig erkannt und zusätzlich installiert.
\end{definition}
Die Erstellung neuer Pakete für OpenWRT wird durch stark modifizierte Makefiles
wesentlich vereinfacht.
 \begin{definition}[Makefile]
Ein \emph{Makefile} ist eine Datei, die Steuerbefehle für das Tool
\texttt{make} enthält. \texttt{make} wird überwiegend eingesetzt, um Quellcode
in ausführbare Programme und Bibliotheken zu übersetzen. Durch seinen hohen
Grad an Abstraktion können \emph{Makefiles} jedoch auch für andere Aufgaben
"`zweckentfremdet"' werden.
\end{definition}

\begin{minipage}[c]{\textwidth}
OpenWRT liefert alle nötigen Bestandteile mit, um ein vollständiges Image für
das eingebettete System zu erstellen.
Der Ablauf ist dabei wie folgt:
\begin{itemize}
  \item Mittels \texttt{make menuconfig} lässt sich der folgende
  Kompiliervorgang in einer grafischen Oberfläche anpassen. Dazu zählen die zu
  erstellenden Anwendungen, Konfigurationsparameter des Kernels und
  Voreinstellungen der Anwendungen.
  \item Durch das Eingeben von \texttt{make} wird der Kompiliervorgang
  gestartet
  \item Der Quellcode der Toolchain wird heruntergeladen und kompiliert
  \item Der Quellcode des Basissystems wird heruntergeladen und kompiliert
  \item Die einzelnen Pakete werden erstellt:
  \begin{itemize}
    \item Herunterladen des Quellcodes
    \item Anwenden von nötigen OpenWRT-Patches
    \item Kompilieren der Anwendung
    \item Erstellen der *.ipk-Datei
  \end{itemize}
\end{itemize}
\end{minipage}

Soll OpenOCD nun auf ARM portiert werden, ist es wünschenswert, das Programm
direkt in diesen Prozess des Paketverwaltungssystems einzubinden. Hierfür muss
ein geeignetes \emph{Makefile} erstellt werden.

\subsection{Wahl eines JTAG-Adapters}
OpenOCD unterstützt eine große Anzahl verschiedener \gls{jtag}-Adapter.
Viele dieser Adapter haben dabei jedoch im Grunde ähnliche Komponenten verbaut.

Neben den industriellen Lösungen mit speziell entwickelten Bauteilen(Segger
J-Link\cite{SEG}, ST Micro ST-Link\cite{STM01}), existieren auch viele
Alternativen, die bereits existierende Bauteile verwenden. So kommt zum Beispiel oft der
\emph{FT2232}-Chip zum Einsatz, der auf die Umsetzung von USB-Daten zu einem
seriellen bzw. parallelen Ausgang spezialisiert ist. Neben kommerziellen
Adaptern (Amontec JTAGkey2\cite{AMO}, Olimex ARM-USB-TINY-H\cite{OLI})
existieren auch einige Open Source Lösungen, in denen der \emph{FT2232} zum
Einsatz kommt (OOCDLink\cite{OCDL}, Turtelizer 2\cite{TURT}). Eine Auflistung
aller mit OpenOCD kompatiblen Adapter findet sich in dessen "`User Guide"'\cite{OOCD}.

Entscheidend für die Wahl eines Adapters sollte zum einen die Anzahl der
unterstützten Zielsysteme sein. Diese definiert sich hauptsächlich über die
vom Adapter unterstützte \textbf{Spannung}. Da viele Mikrocontroller mit
$\SI{3.3}{\volt}$ oder $\SI{5.5}{\volt}$ betrieben werden, sollte der Adapter
zumindest diese beiden Spannungen unterstützen. Je größer diese Spanne jedoch ist, desto flexibler kann
er später eingesetzt werden.

Auch unterscheiden die Adapter sich im Vorhandensein von \textbf{adaptivem
Clocking}. Diese Funktion erlaubt es dem Adapter, sich an die aktuelle
Taktfrequenz des Zielsystems anzupassen. Da viele Mikrocontroller direkt nach
dem Start oder in einem Deep-Sleep-Zustand mit einer geringen Taktzahl arbeiten
und die aktuelle Taktzahl des Zielsystems oftmals die maximal mögliche
\gls{jtag}-Taktzahl vorgibt, müsste der Adapter anderenfalls unter Umständen langsamer
laufen. \emph{Adaptives Clocking} erlaubt es dem Zielsystem, eine Art
"`Rückmeldung"' über die, aktuell gültige, maximale \gls{jtag}-Taktzahl zu geben.

Im Rahmen dieser Arbeit soll der ARM-USB-TINY-H von Olimex zum Einsatz kommen.
Dieser Adapter besitzt einen der verbreiteten \emph{FT2232}-Chips, bietet
Adaptives Clocking und unterstützt einen Spannungsbereich von $\SI{2.0}{\volt}$
bis $\SI{5.0}{\volt}$.

\subsection{Zielsetzung}
\begin{minipage}[c]{\textwidth}
Folgende Punkte sollen im Rahmen dieser Arbeit für ein funktionierendes
Debugsystem umgesetzt werden:
\begin{itemize}
  \item OpenWRT muss kompiliert und konfiguriert werden werden.
  \item Für OpenOCD muss ein \textbf{Makefile} erstellt werden, mithilfe
  dessen über den \linebreak(Cross-)Kompiliervorgang eine Paketdatei für
  OpenWRT erstellt wird.
  \item OpenOCD muss so (vor-)konfiguriert werden, dass sich das Zielsystem
  damit debuggen lässt.
  \item Eine IDE muss so eingerichtet werden, dass sie OpenOCD über \gls{gdb}
  als entfernete Debugging-Schnittstelle verwendet.
\end{itemize}
\end{minipage}
\section{Datenanalyse}\label{sec:datenan}
Ein weiterer wichtiger Bestandteil dieses Entwicklungssystems ist die Analyse
von Daten, die das Zielsystem erzeugt. Da das Zielsystem über eine
Funkschnittstelle verfügt, muss die für das Zielsystem zu entwickelnde
Software diese Schnittstelle sicher auch in Betrieb nehmen können.
\subsection{Szenarien}
Soll für diese Funkschnittstelle nun also z.B. ein neues Funkprotokoll entworfen
werden, ist es sicher nützlich, die Abläufe innerhalb des Funknetzwerkes auf
Korrektheit zu überprüfen.

So sind mehrere Szenarien denkbar, für die eine Analyse der genauen Abläufe
wünschenswert wäre.

\subsubsection*{Reichweite der Zielsysteme}
Da ein zu entwerfendes Netzwerk mitunter eine hohe räumliche Verteilung
aufweist, kann nicht garantiert werden, dass jeder Netzwerkknoten zu jedem
anderen Knoten eine Verbindung aufbauen kann.

Es ist also wünschenswert, die Reichweite mittels der \emph{Datenanalyse}
festzustellen. Hierfür könnte man sich zum Beispiel folgendes simple Szenario
überlegen.

Jeder Netzwerkknoten sendet eine Broadcastmitteilung an das gesamte Netzwerk.
Jeder Knoten der diese Nachricht empfängt, befindet sich nun also in Reichweite
des Absenders.

Für diese Auswertung dieses Vorgangs müssen nun von allen Netzwerkknoten die
erfassten Daten gesammelt und analysiert werden.

\autoref{fig:fikdiag} stellt einen beispielhaften Ablauf eines solchen
Broadcasting-Vorganges dar. Während die zu Zeitpunkt $t_0$ von \emph{Knoten 2}
abgesetzte Nachricht sowohl von \emph{Knoten 1} als auch von \emph{Knoten 3}
empfangen wurde, erreicht die Broadcast-Nachricht von \emph{Knoten1} zu
Zeitpunkt $t_3$ nur \emph{Knoten 2}. In \autoref{fig:fikmsg} ist der mögliche
Ablauf dieses Vorganges aufgeführt, wie er mit zentral gesammelten Daten
erscheinen würde.

Führt man diese Testreihe fort, lässt sich sehr leicht eine Topologie der
Empfangsstärken bilden.

 \begin{figure}[!ht]
 \centering
\begin{sequencediagram}
\newthread[0]{node1}{Knoten 1}
\newthread{node2}{Knoten 2}
\newthread{node3}{Knoten 3}
\mess[1]{node2}{Broadcast}{node1}
\node[anchor=south west,inner sep=8pt] (t0) at (mess from) {$t_0$};
\node[anchor=east,inner sep=10pt] (t1) at (mess to) {$t_1$};
\prelevel{2}
\mess[1]{node2}{Broadcast}{node3}
\node[anchor=west,inner sep=10pt] (t2) at (mess to) {$t_3$};
\mess[1]{node1}{Broadcast}{node2}
\node[anchor=east,inner sep=10pt] (t3) at (mess from) {$t_4$};
\node[anchor=west,inner sep=10pt] (t4) at (mess to) {$t_5$};
\prelevel{2}
\mess[4]{node1}{Broadcast}{node3}
\node[anchor=west,inner sep=10pt] (t5) at (mess to) {$t_6$};
\node[cross out, draw,minimum size = 18pt, thick] at (mess to){};

\end{sequencediagram} \\
\caption{Möglicher Ablauf eines fiktiven Funkprotokolls}{Hier können zu vier
verschiedenen Zeitpunkten Daten aufgezeichnet werden, um einen
zeitlichen Verlauf untersuchen und verdeutlichen zu können.}
\label{fig:fikdiag}
\end{figure}

\begin{figure}[!ht]
\centering
\par\begin{tabu}{l c l}
Zielsystem & Zeitstempel & Nachricht\\
\hline
\emph{<Knoten 2>} & \emph{$t_0$} & Broadcast gesendet\\ 
\emph{<Knoten 1>} & \emph{$t_1$} & Broadcast von \emph{Knoten 2} erhalten\\
\emph{<Knoten 3>} & \emph{$t_2$} & Broadcast von \emph{Knoten 2} erhalten\\
\emph{<Knoten 1>} & \emph{$t_3$} & Broadcst gesendet\\
\emph{<Knoten 2>} & \emph{$t_4$} & Broadcast von \emph{Knoten 1} erhalten\\
\multicolumn{3}{c}{\emph{Keine Daten für Zeitpunkt $t_5$}}\\
\hline
\end{tabu}\\
\caption{Erfassung der Daten des Ablaufs aus \autoref{fig:fikdiag}}{Ein Ablauf
wie in \autoref{fig:fikdiag} dargestellt, könnte diese Reihenfolge von
Nachrichten erzeugen.}
\label{fig:fikmsg}
\end{figure}
\subsubsection*{Kollisionen}\label{subs:kollision}
Auch die Kollisionserkennung ist für ein Funksystem von hoher Bedeutung. Senden
zwei Funkknoten gleichzeitig eine Nachricht, überlagern sich die Funksignale und
es ist für ein empfangendes System, sofern beide Sender in Reichweite sind,
nicht mehr möglich, die einzelnen Nachrichten auseinanderzuhalten.

Hierfür setzt der 802.15.4 Standard in seinem \gls{mac}-Layer zum Beispiel
CSMA/CA ein\cite{IEEE01}.
\begin{definition}[CSMA/CA]
\emph{CSMA/CA} ist ein Algorithmus zur Kollisionsvermeidung innerhalb eines
Netzwerks. Hierbei prüft der Sender vor dem eigentlichen Sendevorgang über
einen definierten Zeitraum, ob das Übertragungsmedium (zum Beispiel Funk oder
Kabel) "`frei"' ist. Wird das Medium bereits verwendet, wartet der der Sender
eine zufällige Zeitperiode (Back-off Periode) und überprüft den Zustand erneut.
Sobald der Sendekanal "`frei"' ist, beginnt der Sendevorgang. Der Empfang der Daten muss
von der Gegenstation mittels \texttt{ACK} bestätigt werden.
\end{definition}
Da \emph{CSMA/CA} jedoch im \gls{mac}-Layer stattfindet und dieser bereits
in das gewählte Funkmodul integriert ist, wird es vermutlich schwierig,
die Daten aus dem Modul selbst zu beziehen. Hier könnte man sich ebenso durch
die Analyse der empfangenen Daten behelfen.

Durch das integrierte \emph{CSMA/CA} lässt sich zwar der Versandzeitpunkt nicht
exakt bestimmen, jedoch aber der Empfangszeitpunkt. Untersucht man nun die
Differenz zwischen Sende- und Empfangsvorgang, lässt sich unter Umständen
erkennen, ob ein Backoff und damit eine erfolgreiche Kollisionsvermeidung
erfolgt ist.

Folgende Rechnung nach\cite{JENN} erläutert die Dauer einer Backoff-Periode.

\begin{align}\label{calc:init}
\mathit{Initialbackoff}_{max} &=(2^{BE}-1)*\mathit{aUnitBackoffPeriod} \\
&=(2^3-1)*\SI{320}{\micro\second}\nonumber \\
&= \SI{2240}{\micro\second} = \SI{2,24}{\milli\second} \nonumber 
\end{align}

Vor jedem Sendevorgang wird nach Spezifikation des \emph{CSMA/CA} ein zufälliger
Zeitraum \emph{InitialbackoffPeriod} gewartet. Erst anschließend wird der Kanal
auf Belegung überprüft. Diese \emph{InitialbackoffPeriod} berechnet sich nach
\autoref{calc:init}. 

Zu dieser Backoff-Periode kommt die anschließende Prüfung auf Belegung
(\gls{cca}) mit einer Dauer von 8 Symbol-Perioden (\SI{128}{\micro\second}). 

Im \SI{2,4}{\giga\hertz}-Band besteht ein Symbol aus 4 Bit. Eine Symbol-Periode
benötigt also, bei einer Übertragungsgeschwindigkeit von
\SI{250}{\kilo\bit\per\second}, eine Dauer von \SI{16}{\micro\second}.
($\frac{\SI{4}{\bit}}{\SI{250}{\kilo\bit\per\second}}=\SI{16}{\micro\second}$)

\emph{aUnitBackoffPeriod} ist in der Spezifikation mit 20 Symbol-Perioden also
\SI{320}{\micro\second} definiert. Zu Beginn ist \emph{BE}, der
Backoff-Exponent, standardmäßig auf 3 eingestellt. Dieser Zähler erhöht sich
jedoch mit jedem Mal, den ein \gls{cca} fehlschlägt.

Selbst für einen erfolgreichen Sendevorgang vergehen also bereits bis zu
\SI{2,24}{\milli\second}. Schlägt das \gls{cca} fehl, wird die
\autoref{calc:init} mit einem um 1 erhöhten \emph{BE} wiederholt und erneut
gewartet. Hierdurch kann ein Datenpaket in der von der IEEE vorgegebenen
Standardkonfiguration um bis zu \SI{9,92}{\milli\second} pro \gls{cca}-Versuch
verspätet werden ($(2^5-1)*\SI{320}{\micro\second = \SI{9920}{\micro\second}}$
mit einem maximalen \emph{BE} von 5).

\begin{figure}[!ht]
\centering
\begin{sequencediagram}
\setthreadbias{center}
\newthread[0]{node1}{Knoten 1}
\newthread[2]{node2}{Knoten 2}
\newthread[2]{node3}{Knoten 3}
\mess[2]{node1}{Anfrage 1}{node2}
\node[anchor=east,inner sep=10pt] (t0) at (mess from) {$t_0$};
\prelevel{2}
\mess[1]{node3}{Anfrage 2}{node2}
\node[anchor=west,inner sep=10pt] (t1) at (mess from) {$t_1$};
\node[anchor=north west,inner sep=10pt] (t2) at (mess to) {$t_2$};
\node[cross out,draw,minimum size = 18pt,very thick] at ($(mess from)!0.5!(mess
to)$) {};
\begin{callself}[5]{node3}{random\_backoff()}{}
\end{callself}
\mess[1]{node3}{Anfrage 2}{node2}
\node[anchor=east,inner sep=10pt] (t3) at (mess to) {$t_3$};
\end{sequencediagram}\\
\caption{Gleichzeitiger Sendevorgang mit Kollisionvermeidung}{Da Knoten 3 vor
seinem ersten Sendevorgang erkennt, dass bereits Daten übertragen werden, muss
er einen zufälligen Zeitraum warten, bevor ein Übertragungsversuch erfolgen
kann.}
\label{fig:kol}
\end{figure}

\autoref{fig:kol} visualisiert einen Sendevorgang mit einspringender
Kollisionsvermeidung. Zu Zeitpunkt $t_0$ beginnt \emph{Knoten
1} mit dem Senden von Daten. \emph{Knoten 3} führt bei $t_1$ ein \gls{cca}
durch und stellt fest, das bereits Daten gesendet werden. Seine Übertragung
wird also um eine Backoff-Periode zurückgestellt. \emph{Knoten 2} empfängt bei
$t_2$ die Daten von \emph{Knoten 1} und eine Weile später bei $t_3$ auch die
Übertragung von \emph{Knoten 3}. 

Da, wie zuvor erwähnt, das \gls{cca} auf Hardware-Ebene erfolgt, lässt sich der
tatsächliche Zeitpunkt des Absendens nicht herausfinden. Jedoch kann man anhand
der Differenz zwischen $t_0$ und $t_2$ erkennen, ob der ursprüngliche
Absendezeitpunkt $t_1$ von der \emph{Anfrage 2} dazwischen liegt. Auch könnte
man über die (vergleichbar große) Differenz zwischen $t_1$ und $t_3$ darauf
schließen, dass die Übertragung aufgrund eines fehlgeschlagenen \gls{cca}
verzögert wurde.

Will man diesen Ablauf zentralisiert erfassen, ergäbe sich im Optimalfall ein
Ablauf wie in \autoref{fig:kolmsg}. Zu Zeitpunkt $t_1$ würde \emph{Knoten 3}
anfänglich die Daten akzeptieren, jedoch hardwareseitig und durch ein
fehlgeschlagenes \gls{cca} noch nicht direkt absenden.

\begin{figure}[!ht]
\centering
\par\begin{tabu}{l c l}
Zielsystem & Zeitstempel & Nachricht\\
\hline
\emph{<Knoten 1>} & \emph{$t_0$} & Anfrage 1 gesendet\\ 
\emph{<Knoten 3>} & \emph{$t_1$} & Anfrage 2 gesendet\\
\emph{<Knoten 2>} & \emph{$t_2$} & Anfrage 1 erhalten\\
\emph{<Knoten 2>} & \emph{$t_3$} & Anfrage 2 erhalten\\
\hline
\end{tabu}\\
\caption{Erfassung der Daten des Ablaufs aus \autoref{fig:kol}}{Ein Ablauf
wie in \autoref{fig:kol} dargestellt, könnte diese Reihenfolge von
Nachrichten erzeugen.}
\label{fig:kolmsg}
\end{figure}

Bei einer maximal spezifizierten Größe des Payloads eines
802.15.4-Paketes von \SI{114}{\byte} werden \SI{4.256}{\milli\second}
zur Übertragung benötigt. Dies zeigt \autoref{calc:data}. Hierbei sind der
\emph{overhead}-Anteil \SI{31}{\byte} bestehend unter anderem aus
Sequenznummer, Adressfeldern und Längenangabe aus \texttt{PHY}- und
\texttt{MAC}-Layer.
\begin{align}\label{calc:data}
\frac{(114+\mathit{overhead)*8}}{\SI{250}{\kilo\bit\per\second}}=\SI{4.256}{\milli\second}
\end{align}

Will man nun die erwähnten Abläufe sinnvoll erfassen, muss die Präzision der
Timer also bei \textbf{mindestens \SI{1}{\milli\second}} liegen. Erst diese
Genauigkeit würde ein sinnvolles Sortieren und Zuordnen der Abläufe ermöglichen.
\subsubsection*{Allgemeines}
Mit steigender Komplexität des zu entwerfenden Funkprotokolls steigt die
Komplexität solcher Abläufe. So ist zum Beispiel, wie im Funkprotokoll ZigBee
vorgesehen, denkbar, dass die Funkknoten verschiedene Aufgaben im Routing und
Aufbau des eigenen Funknetzwerkes übernehmen. Auch hierfür ist unter
Umständen eine möglichst genaue Erfassung der Abläufe nötig.

\subsection{Anforderungen}
Aufgabe dieses Teils des Entwicklungssystems wird es sein, die Erfassung der in
\autoref{sec:datenan} erwähnten Abläufe zu erleichtern.

Bedingung für die Erfassung von Daten seitens des Entwicklungssystems ist, dass
das Zielsystem diese Daten überhaupt in einer erfassbaren Form zur Verfügung
stellt. Hierbei muss jedoch beachtet werden, dass nicht jedes Zielsystem über
alle Anschlussmöglichkeiten verfügen kann.

Um die Daten vom Zielsystem zu erfassen, bietet sich zum Beispiel die Nutzung
des \textbf{\gls{uart}} an. Hierfür muss jedoch die Software des Zielsystems so
angepasst werden, dass es die zu sammelnden Daten über \gls{uart} ausgibt.

\begin{definition}[UART]
Der \gls{uart} ist eine, in Mikrocontrollern sehr weit verbreitete,
elektronische Schaltung zur seriellen Übertragung von Daten. In
seiner Minimalkonfiguration benötigt der \gls{uart} nur zwei Pins (RX ---
Receive, TX --- Transmit), da, durch Festlegung auf einen gemeinsamen Takt, auf
ein Taktsignal verzichtet werden kann. Dies ermöglicht eine Nutzung von
\gls{uart} auch in einem stark integriertem Zielsystem.
\end{definition}

\begin{minipage}[c]{\textwidth}
Um die Daten später sortieren und analysieren zu können, müssen vom
Entwicklungssystem folgende Daten erfasst werden.
\begin{itemize}
  \item Vom Zielsystem ausgegebene Daten
  \item Zeitpunkt der Erfassung der Daten
\end{itemize}
\end{minipage}

Besonderes Augenmerk muss hierbei auf die Synchronizität der einzelnen Module
des Entwicklungssystems gelegt werden. Auf diesen Umstand wird in
\autoref{subs:time} weiter eingegangen. 

\subsection{Bestandteile}\label{subs:best}
\begin{minipage}[c]{\textwidth}
Die Software zur Analyse der gesammelten Daten muss im Kern aus drei Teilen
bestehen.
\begin{itemize}
  \item \textbf{Server} --- Läuft als Anwendung auf dem Carambola. Empfängt
  Daten über \gls{uart} und leitet diese an den Client weiter.
  \item \textbf{Client} --- Läuft auf dem System des Entwicklers. Verbindet sich
  zu der Serveranwendung und empfängt von ihr die gesammelten Daten.
  \item \textbf{Protokoll} --- Definiert die Kommunikation zwischen Server und
  Client.
\end{itemize}
\end{minipage}\par
Für die \emph{Clientanwendung} ist es von großer Bedeutung, dass sie sich zu
mehreren Serverinstanzen verbinden kann. Nur hierdurch wird es möglich, die
Daten von mehreren Zielsystemen erfassen und auswerten zu können.

Für die \emph{Serveranwendung} ist es nicht unbedingt notwendig aber
wünschenswert, mehrere verbundene \emph{Clients} verwalten zu können.
\subsection{Zeitsynchronisation}\label{subs:time}
Ein wichtiger Punkt im Entwurf dieses Systems ist die \textbf{Synchronisation
der Uhren} der jeweiligen Module. Nur so kann eine Vergleichbarkeit der
verarbeiteten Daten gewährleistet werden.

Aus \autoref{subs:kollision} ergibt sich, dass eine Präzision von mindestens
\SI{1}{\milli\second} gewährleistet werden sollte. Zu den nicht beeinflussbaren
Größen zählen hierbei zum Beispiel die für einen Kontextwechsel durch den
Scheduler des Betriebssystems nötige Zeit oder die Genauigkeit des
Systemquarzes.

Da der zu übertragene Zeitstempel die seit eines durch den Entwickler-Rechner
festgelegten Zeitpunktes vergangenen $\si{\micro\second}$ darstellt, muss diese
Zahl ausreichend groß dimensioniert sein. Eine 32-Bit Zahl reicht unter
Umständen für die Betrachtung längerer Zeitabstände nicht mehr aus
($2^{32}\si{\micro\second}\approx \SI{71}{\minute}$).

Eine 64-Bit Zahl bleibt somit als einzige Möglichkeit. Sie bietet ausreichend
viel Platz ($2^{64}\si{\micro\second}\approx 584942~years$), um auch
über sehr große Zeiträume Daten aufzuzeichnen.

\subsection{Protokoll}
Damit der Client und die Serveranwendungen über das Netzwerk kommunizieren
können, wird ein Protokoll zum Datenaustausch spezifiziert. Dieses Protokoll
legt sowohl den Aufbau der Datenpakete als auch die Abläufe der Kommunikation
fest.

Während die Übertragung der Nutzdaten (vom Zielsystem ausgegebene Daten) über
TCP erfolgt, läuft die Zeitsynchronisation über UDP ab. Die Verwendung von UDP
garantiert, dass keine Mehrfachübertragung eines fehlerhaften Datenpaketes
erfolgt, welche eine korrekte Zeitmessung verhindern würde.

Für die Übertragung der Nutzdaten ist aber zu entscheiden ob der Nagle
Algorithmus\cite{RFC896} deaktiviert werden muss, da die Daten ansonsten unter
Umständen zu stark verzögert werden.

Um das Protokoll erweiterbar zu halten, sollte es eine Möglichkeit geben, das
System später um andere Nutzdatentypen wie zum Beispiel Ausgaben einer SPI oder
I$^2$C-Schnittstelle erweitern zu können.

\begin{minipage}[c]{\textwidth}
Das Protokoll soll folgende Funktionen erlauben:
\begin{itemize}
  \item Zeitsynchronisation wie in \autoref{subs:time} aufgeführt
  \item Übertragung von UART-Daten
  \item Erweiterungsmöglichkeit für andere Datentypen
\end{itemize}
\end{minipage}

Jedes Datenpaket besteht dafür aus einem \textbf{Pakettyp}, der \textbf{Länge}
(Anzahl Byte) der Nutzdaten, einem \textbf{Zeitstempel} und optional den
\textbf{Nutzdaten}. Die Übertragung erfolgt dabei, wie für die meisten
Netzwerkprotokolle üblich, in Big-Endian. Der Aufbau eines Datenpaketes ist in
\autoref{fig:bytefield} visualisiert.

Die Größe des Headers beträgt 11 Byte und setzt sich wie folgt zusammen:\\
Für die Bestimmung des \textbf{Typs} eines Datenpaketes reichen 8 Bit. Dies
ermöglicht 256 verschiedene Pakettypen und somit ausreichend Spielraum für
potentielle Erweiterungen. Die Größe des \textbf{Zeitstempels} mit 64 Bit ist in
\autoref{subs:time} erläutert worden. Die maximale Größe der an ein
Datenpaket anhängbaren Nutzdaten ist auf 512 Byte beschränkt. Dies erscheint
ausreichend groß für "`kurze"' Statusnachrichten. Hieraus ergibt sich, dass für
die Angabe der \textbf{Länge} 16 Bit benötigt werden.

\begin{figure}[h!]
\centering
\begin{bytefield}[bitheight=3.3ex,bitwidth=3em,endianness=big]{8}
\bitheader{0-7} \\
\begin{rightwordgroup}{Header}
\wordbox{1}{Type (1 Byte)} \\
\wordbox{2}{Length (2 Byte)} \\
\wordbox{8}{Timestamp (8 Byte)}
\end{rightwordgroup} \\
\wordbox[lrt]{1}{Data (n Byte)} \\
\skippedwords \\
\wordbox[lrb]{1}{}
\end{bytefield} \\
\caption{Systematischer Aufbau eines Datenpaketes}{Der Aufbau eines TCP-Paketes
ist mit dem eines UDP-Paketes identisch. Die Menge \emph{n} der Daten ist
auf 512 Byte beschränkt.}
\label{fig:bytefield}
\end{figure}
Aus dem Ablauf in \autoref{subs:time} ist ersichtlich, dass einzig für die
\texttt{PING}-Nachricht und unter Umständen auch für die \texttt{STIM}-Nachricht
eine Verwendung des Zeitstempels wichtig ist. Verlagert man den Zeitstempel der
\texttt{STIM}-Nachricht innerhalb des Datenpaketes in den Bereich der
\emph{Nutzdaten}, lässt sich das \emph{Zeitstempel}-Feld im UDP-Ablauf als
Sequenznummer verwenden. Die erste \texttt{PING}-Nachricht übermittelt somit
indirekt auch die für den Synchronisierungsablauf notwendige Sequenznummer in
Form ihres eigenen Zeitstempels.

In \autoref{fig:prot} sind die verschiedenen Pakettypen aufgeführt. 
\begin{figure}[h!]
\centering
\begin{tabu}{l l l p{7cm}}
\multicolumn{3}{c}{\textbf{Server zu Client}}\\ \cline{1-3}
Protokoll & Abkürzung & Wert & Beschreibung \\ \hline
TCP & MESS & \texttt{0x01} & Allgemeine Nachricht des Servers. Eventuell als
Broadcast verursacht durch MESS von einem Client. \\
& UART & \texttt{0x02} & Der Server hat eine UART-Zeile empfangen. Die
empfangenen Daten sind als Payload angehängt. \\
& SPID & \texttt{0x03} & Der Server hat eine SPI-Zeile empfangen. Die
empfangenen Daten sind als Payload angehängt. \\
UDP & PONG & \texttt{0x06} & Antwort des Servers auf PING vom Client.
Zeitstempel identisch mit PING.\\
\hline \\
\multicolumn{3}{c}{\textbf{Client zu Server}}\\ \cline{1-3}
Protokoll & Abkürzung & Wert & Beschreibung \\
\hline
TCP & MESS & \texttt{0x01} & Payload an alle verbundenen Clients senden.
(Broadcastfunktion)\\
& EXIT & \texttt{0x10} & Den Server zum Schließen aller Verbindungen und Beenden
der Serveranwendung veranlassen. \\
UDP & PING & \texttt{0x05} & Einen Ping
mit aktuellem Zeitstempel des Clients senden. \\
& STIM & \texttt{0x04} & Letzter Schritt der Zeitsynchronisation. Den Zeitpunkt
des zuletzt erhaltenen \emph{PONG} als Payload anhängen. Zeitstempel identisch
mit PONG.\\
\hline \end{tabu}\\
\caption{Nachrichtentypen des Protokolls}{In dieser Tabelle ist mit
"`Client"' das Softwaremodul auf dem Entwickler-PC und als "`Server"' das
Gegenstück auf dem eingebetteten System gemeint. Die Spalte "`Wert"' enthält die
im Header als "`Typ"' bezeichnete Kodierung des Pakettyps.}
\label{fig:prot}
\end{figure}

\section{Deployment}
Die zum \emph{Debuggen} bereits bestehende \gls{jtag}-Verbindung lässt sich
ebenso verwenden, um Software auf das Zielsystem zu bringen.

Grundvoraussetzung ist hierfür jedoch, dass sich das \gls{rom} des Zielsystems
über den \gls{tap} erreichen lässt. Dies ist bei dem verwendeten ST Cortex M3
(und vielen anderen Mikrocontrollern) der Fall.
\subsection{Zielsetzung}
Es muss ein Skript für einen \gls{gdb}-Client erstellt werden, das es erlaubt,
eine beliebige Anzahl Zielsysteme mit einer neuen Firmware zu versorgen.
<\ldots>