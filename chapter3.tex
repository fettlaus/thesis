\chapter{Konzeption}
\minitoc
In diesem Kapitel soll das Entwicklungssystem konzipiert werden.
Dazu muss jedes Element auf seine zu erfüllende Funktion untersucht werden.

Hieraus ergibt sich im Anschluss der anzufordernde Funktionsumfang, den der
jeweilige Bestandteil zu erfüllen hat.

Nach einer Analyse bereits existierender Systeme folgt schließlich die
Festlegung auf ein Entwicklungsziel.

Letztendlich muss sichergestellt werden, dass alle einzelnen Komponenten in dem
zu planenden System miteinander interagieren. Es müssen also
Schnittstellenspezifikationen festgelegt werden.
\section{Debugging}
\subsection{Definition}
Das Debugging eines eingebetteten Systems erfordert meist eine kombinierte Hard-
und Softwarelösung.

Der Softwareteil ist oft in die \gls{ide} des Entwicklers eingebunden oder lässt
sich zumindest vom Arbeitsplatz des Entwicklers aus steuern. Die Befehle des
Entwicklers (Setzen eines Breakpoints, Abfrage von Registerwerten, etc.) werden
vom Softwaretreiber anschließend in Steuerbefehle des Hardwarebauteils
umgesetzt. Das Hardwaremodul übernimmt hierauf, unter Nutzung eine
standardisierten Schnittstelle, die Kommunikation mit dem Zielsystem.

Als Schnittstellen sind für diese Zwecke vor allem \gls{jtag} und \gls{swd}
verbreitet. Während \gls{jtag} ursprünglich primär zum Testen von Bauteilen
konzipiert wurde, erweitert \gls{swd} dieses Konzept um speziell für das
Debuggen nützliche Funktionen (Tracing, Paritätschecks) und reduziert die Anzahl
zwingend notwendiger Pins von 4 auf 2. Da \gls{swd} aber von ARM speziell
für Prozessoren mit eingebautem CoreSight-Modul entwickelt wurde, ist
Unterstützung hierfür nicht auf allen ARM-Controllern anzutreffen. \gls{jtag}
hat hier eine wesentlich größere Verbreitung und wird auch
architekturübergreifend genutzt (Die Wahl von \gls{jtag} würde eine spätere
Erweiterung auf andere Architekturen somit erleichtern).
\subsection{Marktübersicht}
Die Auswahl bereits existierender Netzwerk-Debugging-Lösungen ist geradezu
minimal.
Als eigenständige Lösung findet sich hier zum Beispiel \emph{ZY1000 (Ultimate
Solutions Inc.)} oder \emph{WiFiDemon (Macraigor Systems)}. Beide Systeme
stellen eine Schnittstelle zwischen Ethernet oder WLAN dar und sind somit
bereits existierende Umsetzungen des geplanten \emph{Entwicklungssystems}, wenn
man es auf den Aspekt des Debugging reduzieren würde.

Beide Lösungen sind jedoch geschlossene Systeme. Wollte man also, wie
vorgesehen, zusätzliche Daten sammeln, müsste man ein weiteres Gerät (mit
eigenem Anschluss an das Netzwerk) verwenden.

Betrachtet man die Softwareseite des Debuggings, landet man beinahe
zwangsläufig beim Open Source Projekt \textbf{OpenOCD}. Dieses Projekt ist im
Rahmen einer Diplomarbeit\cite{OOCD2} an der FH Augsburg entstanden und hatte
die Entwicklung einer quelloffenen Software zum Debuggen von
ARM-Mikrocontrollern zum Ziel. OpenOCD fungiert dabei als Schnittstelle zwischen
einem \gls{jtag}-Debugger und einer Benutzeroberfläche.

OpenOCD lässt sich dabei entweder über eine eigene Benutzeroberfläche via
Telnet-Protokoll oder mittels eines \gls{gdb}-Clients bedienen.
\begin{definition}[GDB]
Der \gls{gdb} ist der Standard-Debugger unter
Unix-Betriebssystemen. Er bietet unter Anderem die Möglichkeit, ein Programm im
laufenden Betrieb anzuhalten, Breakpoints zu setzen oder Single-Stepping
durchzuführen. Der GDB lässt besitzt keine grafische Oberfläche, sondern
lässt sich über eine Kommandozeile bedienen. Er bietet die Möglichkeit, von
einem Client über TCP/IP ferngesteuert zu werden. 
\end{definition}
\subsection{Cross-Compilierung}
In einigen Fällen ist es nicht praktikabel oder schlicht unmöglich, dass eine
Anwendung auf der CPU-Architektur kompiliert wird, die auch später die
ausführende Architektur ist. Dies kann zum Beispiel dann der Fall sein, wenn ein
engebettetes System über nicht ausreichend Ressourcen (Speicherplatz) verfügt,
um den Kompilationsvorgang durchzuführen.

In diesen Fällen kommt ein sogenannter \emph{Cross-Compiler} zum Einsatz.
\subsection{OpenWRT - Paketverwaltung und Kompiliervorgang}
OpenWRT besitzt mit \textbf{opkg} ein Tool zur Paketverwaltung von Anwendungen.
Hierbei kann die Software in Form von *.ipk-Files aus sogenannten "`Repositories"'
heruntergeladen und anschließend installiert werden. Durch dieses Tool wird es
möglich, das eingebettete System für die eigenen Bedürfnisse anzupassen.

Die Erstellung neuer Pakete für OpenWRT wird durch stark modifizierte Makefiles
wesentlich vereinfacht.
 \begin{definition}[Makefile]
Ein \emph{Makefile} ist eine Datei, die Steuerbefehle für das Tool
\texttt{make} enthält. \texttt{make} wird überwiegend eingesetzt, um Quellcode
in ausführbare Programme und Bibliotheken zu übersetzen. Durch seinen hohen
Grad an Abstraktion können \emph{Makefiles} jedoch auch für andere Aufgaben
"`zweckentfremdet"' werden.
\end{definition}
OpenWRT liefert alle nötigen Bestandteile mit, um ein vollständiges Image für
das eingebettete System zu erstellen.
Der Ablauf ist dabei wie folgt:
\begin{itemize}
  \item Mittels \texttt{make menuconfig} lässt sich der folgende
  Kompiliervorgang in einer grafischen Oberfläche anpassen. Dazu zählen die zu
  erstellenden Anwendungen, Konfigurationsparameter des Kernels und
  Voreinstellungen der Anwendungen.
  \item Durch das Eingeben von \texttt{make} wird der Kompiliervorgang
  gestartet
  \item Der Quellcode der Toolchain wird heruntergeladen und kompiliert
  \item Der Quellcode des Basissystems wird heruntergeladen und kompiliert
  \item Die einzelnen Pakete werden erstellt:
  \begin{itemize}
    \item Herunterladen des Quellcodes
    \item Anwenden von nötigen OpenWRT-Patches
    \item Kompilieren der Anwendung
    \item Erstellen der *.ipk-Datei
  \end{itemize}
\end{itemize}

Soll OpenOCD nun auf ARM portiert werden, ist es wünschenswert, das Programm
direkt in diesen Prozess des Paketverwaltungssystems einzubinden. Hierfür muss
ein geeignetes \emph{Makefile} erstellt werden.

\subsection{Wahl eines JTAG-Adapters}
OpenOCD unterstützt eine große Anzahl verschiedener JTAG-Adapter. Viele dieser
Adapter haben dabei jedoch im Grunde ähnliche Komponenten verbaut.

Neben den industriellen Lösungen mit speziell entwickelten Bauteilen(Segger
J-Link, ST Micro ST-Link), existieren auch viele Alternativen, die bereits
existierende Bauteile verwenden. So kommt zum Beispiel oft der
\emph{FT2232}-Chip zum Einsatz, der auf die Umsetzung von USB-Daten zu einem
seriellen bzw. parallelen Ausgang spezialisiert ist. Neben kommerziellen
Adaptern (Amontec JTAGkey2, Olimex ARM-USB-TINY-H) existieren auch einige Open
Source Lösungen, in denen der \emph{FT2232} zum Einsatz kommt (OOCDLink,
Opendous). 

Entscheidend für die Wahl eines Adapters sollte zum einen die Anzahl der
unterstützten Zielsysteme sein. Diese definiert sich hauptsächlich über die
vom Adapter unterstützte \textbf{Spannung}. Da viele Mikrocontroller mit
$3.3\volt$ oder $5.5\volt$ betrieben werden, sollte der Adapter zumindest diese beiden
Spannungen unterstützen. Je größer diese Spanne jedoch ist, desto flexibler kann
er später eingesetzt werden.

Auch unterscheiden die Adapter sich im Vorhandensein von \textbf{adaptivem
Clocking}. Diese Funktion erlaubt es dem Adapter, sich an die aktuelle
Taktfrequenz des Zielsystems anzupassen. Da viele Mikrocontroller direkt nach
dem Start oder in einem Deep-Sleep-Zustand mit einer geringen Taktzahl arbeiten
und die aktuelle Taktzahl des Zielsystems oftmals die maximal mögliche
JTAG-Taktzahl vorgibt, müsste der Adapter anderenfalls unter Umständen langsamer
laufen. \emph{Adaptives Clocking} erlaubt es dem Zielsystem, eine Art
"`Rückmeldung"' über die, aktuell gültige, maximale JTAG-Taktzahl zu geben.

Im Rahmen dieser Arbeit soll der ARM-USB-TINY-H von Olimex zum Einsatz kommen.
Dieser Adapter besitzt einen der verbreiteten \emph{FT2232}-Chips, bietet
Adaptives Clocking und unterstützt einen Spannungsbereich von $2.0\volt$ bis
$5.0\volt$.

\subsection{Zielsetzung}
Folgende Punkte sollen im Rahmen dieser Arbeit für ein funktionierendes
Debugsystem umgesetzt werden:
\begin{itemize}
  \item OpenWRT muss kompiliert und konfiguriert werden werden.
  \item Für OpenOCD muss ein \textbf{Makefile} erstellt werden, mithilfe
  dessen über den \linebreak(Cross-)Kompiliervorgang eine Paketdatei für
  OpenWRT erstellt wird.
  \item OpenOCD muss so (vor-)konfiguriert werden, dass sich das Zielsystem
  damit debuggen lässt.
  \item Eine IDE muss so eingerichtet werden, dass sie OpenOCD über \gls{gdb}
  als entfernete Debugging-Schnittstelle verwendet.
\end{itemize}
\section{Datenanalyse}\label{sec:datenan}
Ein weiterer wichtiger Bestandteil dieses Entwicklungssystems ist die Analyse
von vom Zielsystem erzeugten Daten. Da das Zielsystem über eine
Funkschnittstelle verfügt, muss eine, für das Zielsystem zu entwickelnde,
Software diese Schnittstelle sicher auch in Betrieb nehmen können.

Soll für diese Funkschnittstelle nun also z.B. ein neues Funkprotokoll entworfen
werden, ist es sicher nützlich, die Abläufe innerhalb des Funknetzwerkes auf
Korrektheit zu überprüfen.
\begin{figure}[h!]
\begin{sequencediagram}
\newthread{node1}{Netzwerkknoten 1}
\newthread{node2}{Netzwerkknoten 2}
\mess[1]{node1}{Verbindungsanfrage}{node2}
\node[anchor=east,inner sep=10pt] (t0) at (mess from) {$t_0$};
\node[anchor=west,inner sep=10pt] (t1) at (mess to) {$t_1$};
\mess[1]{node2}{Bestätigung}{node1}
\node[anchor=west,inner sep=10pt] (t2) at (mess from) {$t_2$};
\node[anchor=east,inner sep=10pt] (t3) at (mess to) {$t_3$};
\end{sequencediagram}
\centering \\
\caption{Möglicher Ablauf eines fiktiven Funkprotokolls}{Hier können zu vier
verschiedenen Zeitpunkten Daten aufgezeichnet werden, um einen
zeitlichen Verlauf untersuchen und verdeutlichen zu können.}
\label{fig:fikdiag}
\end{figure}

In \autoref{fig:fikdiag} sieht man ein einfaches Beispiel für eine
Verbindungsanfrage eines fiktiven Funksystems. Die zu erfassenden Daten
bestünden in diesem Fall zum Beispiel aus Textnachrichten der Zielsysteme. Würde
man diese Daten nun erfassen und in einem System gebündelt anzeigen, könnte man
den genauen Ablauf, wie in \autoref{fig:fikmsg} dargestellt, genau
nachvollziehen.
\begin{figure}[ht!]
\centering
\par\begin{tabu}{l c l}
Zielsystem & Zeitstempel & Nachricht\\
\hline
\emph{<Netwerkknoten 1>} & \emph{$t_0$} & Verbindungsanfrage gesendet\\ 
\emph{<Netwerkknoten 2>} & \emph{$t_1$} & Verbindungsanfrage erhalten\\
\emph{<Netwerkknoten 2>} & \emph{$t_2$} & Bestätigung gesendet\\
\emph{<Netwerkknoten 1>} & \emph{$t_3$} & Bestätigung erhalten\\
\hline
\end{tabu}\\
\caption{Erfassung der Daten des Ablaufs aus \autoref{fig:fikdiag}}{Ein Ablauf
wie in \autoref{fig:fikdiag} dargestellt, könnte diese Reihenfolge von
Nachrichten erzeugen.}
\label{fig:fikmsg}
\end{figure}
Mit steigender Komplexität des zu
entwerfenden Funkprotokolls steigt jedoch auch die Komplexität solcher Abläufe.
So ist zum Beispiel, wie im Funkprotokoll ZigBee vorgesehen, denkbar, dass die
Funkknoten verschiedene Aufgaben im Routing und Aufbau des eigenen
Funknetzwerkes übernehmen.

\subsection{Anforderungen}
Aufgabe dieses Teil des Entwicklungssystems wird es sein, die Erfassung der in
\autoref{sec:datenan} erwähnten Abläufe zu erleichtern.

Bedingung für die Erfassung von Daten seitens des Entwicklungssystems ist, dass
das Zielsystem diese Daten überhaupt in einer erfassbaren Form zur Verfügung
stellt. Hierbei muss jedoch beachtet werden, dass nicht jedes Zielsystem über
alle Anschlussmöglichkeiten verfügen kann.

Um die Daten vom Zielsystem zu erfassen, bietet sich zum Beispiel die Nutzung
des \textbf{\gls{uart}} an. Hierfür muss jedoch die Software des Zielsystems so
angepasst werden, dass es die zu sammelnden Daten über \gls{uart} ausgibt.

\begin{definition}[UART]
Der \gls{uart} ist eine, in Mikrocontrollern sehr weit verbreitete,
elektronische Schaltung zur seriellen Übermittlung und Empfang von Daten. In
seiner Minimalkonfiguration benötigt der \gls{uart} nur zwei Pins (RX ---
Receive, TX --- Transmit), da auf ein Taktsignal verzichtet werden kann. Dies
ermöglicht eine Nutzung von \gls{uart} auch in einem stark integriertem
Zielsystem.
\end{definition}

Um die Daten später sortieren und analysieren zu können, müssen vom
Entwicklungssystem folgende Daten erfasst werden.
\begin{itemize}
  \item Vom Zielsystem ausgegebene Daten
  \item Zeitpunkt der Erfassung der Daten
\end{itemize}
Besonderes Augenmerk muss hierbei auf die Synchronizität der einzelnen Module
des Entwicklungssystems gelegt werden. Auf diesen Umstand wird in
\autoref{subs:time} weiter eingegangen. 

\subsection{Bestandteile}
Die Software zur Analyse der gesammelten Daten muss im Kern aus drei Teilen
bestehen.
\begin{itemize}
  \item \textbf{Server} --- Läuft als Anwendung auf dem Carambola. Empfängt
  Daten über \gls{uart} und leitet diese an den Client weiter.
  \item \textbf{Client} --- Läuft auf dem System des Entwicklers. Verbindet sich
  zu der Serveranwendung und empfängt von ihr die gesammelten Daten.
  \item \textbf{Protokoll} --- Definiert die Kommunikation zwischen Server und
  Client.
\end{itemize}

\subsection{Zeitsynchronisation}\label{subs:time}
Ein wichtiger Punkt im Entwurf dieses Systems ist die \textbf{Synchronisation
der Uhren}. Da jedes Entwicklungsmodul zu einem

Ein erster Ansatz wäre hier, bereits bestehende Synchronisationstechniken wie
\gls{ntp} zu verwenden. Diese haben jedoch den Nachteil, dass sie für die
Synchronisation immer eine aktive Verbindung zum Internet oder einen lokalen
NTP-Server  benötigen. Außerdem sind, da die Carambola-Systeme keine
Echtzeituhren besitzen, Datum und Uhrzeit nach einem Start des Systems auf die
Unix Epoche gesetzt. Da NTP direkt die Systemzeit beeinflusst, würde dies 
unter Umständen Auswirkungen auf andere Prozesse bedeuten.

Für die Zeitsynchronisation soll eine Abwandlung des Algorithmus von Christian
zum Einsatz kommen. Entscheidend ist hierbei, dass der Synchronisationsvorgang
vom Zeitgeber angestoßen wird. Dies erfordert eine zusätzliche
abschließende Datenübertragung.
\begin{itemize}
  \item Der Client stößt den Synchronisationsvorgang an, indem er dem Server
  seinen aktuellen Zeitstempel $t_0$ mittels einer \texttt{PING}-Nachricht
  übermittelt.
  \item Bei Erhalt der Nachricht erfasst der Server seinen eigenen Zeitstempel
  als $t_1$.
  \item Anschließend bereitet er das Senden einer \texttt{PONG}-Nachricht als
  Antwort vor, erfasst einen weiteren Zeitstempel ($t_2$) und sendet die
  Nachricht.
  \item Bei Erhalt der Nachricht durch den Client, erfasst dieser seine eigene
  Zeit $t_3$ und übermittelt sie dem Server in einer, diesen
  Synchronisierungsprozess abschließenden, \texttt{STIM}-Nachricht.
\end{itemize} 
Dieser Vorgang ist in \autoref{fig:timeseq} visualisiert.
\begin{figure}
\centering
\begin{sequencediagram}[ht]
\newthread{client}{:Client}
\newthread{server}{:Server}
\mess[2]{client}{PING}{server}
\node[anchor=east,inner sep=10pt] (t0) at (mess from) {$t_0$};
\node[anchor=west,inner sep=4pt,label=above right:{$t_1$}] (t1) at (mess to)
{};
\mess[2]{server}{PONG}{client}
\node[anchor=west,inner sep=4pt,label=below right:{$t_2$}] (t2) at (mess from)
{}; \node[anchor=east,inner sep=10pt] (t3) at (mess to) {$t_3$};
\mess[2]{client}{STIM}{server}
\path (t0.east) |- coordinate(t01) (t1);
\draw[dashed] (t1) -- (t01);
\path (t3.east) |- coordinate(t23) (t2);
\draw[dashed] (t2) -- (t23);
\end{sequencediagram}
\caption{Ablauf der Zeitsynchronisation eines Servers}
\label{fig:timeseq}
\end{figure}

Nach Abschluss dieser Kommunikation lässt sich die Zeitdifferenz durch folgende
Formel errechnen.
\begin{equation}
\frac{t_1-t_0-t_3+t_2}{2}=\Delta t
\end{equation}
Um Abweichungen zum Beispiel durch unterschiedliche Latenzen auf dem Hin- und
Rückweg im Netzwerk auszugleichen, werden mehrere dieser Vorgänge durchgeführt
und ein arithmetisches Mittel über die gesammelten Differenzen gebildet. Dieses
stellt dann die zu verwendende Differenz dar.

\subsection{Protokoll}
Damit Die Client- und die Serveranwendung über das netzwerk kommunizieren
können, wird ein Protokoll zum Datenaustausch spezifiziert. Dieses Protokoll
legt sowohl den Aufbau der Datenpakete als auch die Abläufe der Kommunikation
fest.

Während die Übertragung der Nutzdaten (vom Zielsystem ausgegebene Daten) über
TCP erfolgt, läuft die Zeitsynchronisation über UDP ab.

<\ldots>

<Hierzu gehören auch noch \autoref{fig:prot}, \autoref{fig:bytefield} und
Erklärungen dazu>
\begin{figure}[ht!]
\centering
\begin{tabu}{l l l p{7cm}}
\multicolumn{3}{c}{\textbf{Server zu Client}}\\ \cline{1-3}
Protokoll & Abkürzung & Wert & Beschreibung \\ \hline
TCP & MESS & \texttt{0x01} & Allgemeine Nachricht des Servers. Eventuell als
Broadcast verursacht MESS von einem Client. \\
& UART & \texttt{0x02} & Der Server hat eine UART-Zeile empfangen. Die
empfangenen Daten sind als Payload angehängt. \\
& SPID & \texttt{0x03} & Der Server hat eine SPI-Zeile empfangen. Die
empfangenen Daten sind als Payload angehängt. \\
UDP & PONG & \texttt{0x06} & Antwort des Servers auf PING vom Client.
Zeitstempel identisch mit PING.\\
\hline \\
\multicolumn{3}{c}{\textbf{Client zu Server}}\\ \cline{1-3}
Protokoll & Abkürzung & Wert & Beschreibung \\
\hline
TCP & MESS & \texttt{0x01} & Payload an alle verbundenen Clients senden.
(Broadcastfunktion)\\
& EXIT & \texttt{0x10} & Den Server zum Schließen aller Verbindungen und Beenden
der Serveranwendung veranlassen. \\
UDP & PING & \texttt{0x05} & Einen Ping
mit aktuellem Zeitstempel des Clients senden. \\
& STIM & \texttt{0x04} & Letzter Schritt der Zeitsynchronisation. Den Zeitpunkt
des zuletzt erhaltenen \emph{PONG} als Payload anhängen. Zeitstempel identisch
mit PONG.\\
\hline \end{tabu}\\
\caption{Nachrichtentypen des Protokolls}{\emph{In dieser Tabelle ist mit
"`Client"' das Softwaremodul auf dem Entwickler-PC und als "`Server"' das Gegenstück auf
dem eingebetteten System gemeint.}}
\label{fig:prot}
\end{figure}
\begin{figure}[ht!]
\centering
\begin{bytefield}[bitheight=3.3ex,bitwidth=3em,endianness=big]{8}
\bitheader{0-7} \\
\begin{rightwordgroup}{Header}
\wordbox{1}{Type (1 Byte)} \\
\wordbox{2}{Length (2 Byte)} \\
\wordbox{8}{Timestamp (8 Byte)}
\end{rightwordgroup} \\
\wordbox[lrt]{1}{Data (n Byte)} \\
\skippedwords \\
\wordbox[lrb]{1}{}
\end{bytefield}
\caption{Systematischer Aufbau eines Datenpaketes}
\label{fig:bytefield}
\end{figure}
\section{Deployment}
<\ldots>
\subsection{Übersicht}
<\ldots>
\subsection{Zielsetzung}
<\ldots>